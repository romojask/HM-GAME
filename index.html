<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#0b1220" />
  <title>HM GAME</title>
  <style>
    :root{
      --bg:#070d18;
      --glass: rgba(255,255,255,.08);
      --glass2: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.14);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);

      --padBase: rgba(240,240,240,.88);
      --padShadow: rgba(0,0,0,.35);
      --padDark: rgba(20,22,28,.92);

      --A:#e43b3b;
      --B:#f0c535;
      --X:#2d71ff;
      --Y:#2ecc71;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 900px at 70% 15%, #1b2a55, var(--bg));
      color:var(--txt);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* App layout: TOP screen + BOTTOM controller */
    .app{
      height: 100dvh;
      display:grid;
      grid-template-rows: 1fr auto;
    }

    .screenWrap{
      position:relative;
      padding: 10px;
      padding-top: calc(10px + env(safe-area-inset-top));
    }

    /* Screen frame */
    .screenFrame{
      height: 100%;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.25);
      box-shadow: 0 20px 70px rgba(0,0,0,.40);
      overflow:hidden;
      position:relative;
    }

    canvas#cv{
      width:100%;
      height:100%;
      display:block;
      background: #050b14;
    }

    /* Bottom controller area */
    .pad{
      padding: 12px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      background: rgba(0,0,0,.18);
    }

    .padBody{
      max-width: 900px;
      margin: 0 auto;
      border-radius: 26px;
      border: 1px solid rgba(255,255,255,.10);
      background: var(--padBase);
      box-shadow: 0 16px 60px var(--padShadow);
      padding: 14px;
      position:relative;
      overflow:hidden;
    }

    /* Slight transparent glossy band */
    .padBody:before{
      content:"";
      position:absolute; inset:-40% -20% auto -20%;
      height: 70%;
      transform: rotate(-10deg);
      background: rgba(255,255,255,.22);
      filter: blur(0px);
      pointer-events:none;
    }

    .padTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }

    .shoulder{
      flex: 1 1 0;
      border-radius: 16px;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(0,0,0,.12);
      padding: 10px 12px;
      font-weight: 1000;
      color: rgba(0,0,0,.70);
      user-select:none;
    }

    .padMain{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:center;
      gap: 14px;
    }

    /* D-Pad */
    .dpad{
      display:grid;
      justify-items:center;
      gap:8px;
    }
    .dpadMid{display:flex; gap:8px; align-items:center}
    .btn{
      border:none;
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }
    .btn:active{ transform: translateY(1px); }

    .padBtn{
      width: 68px; height: 58px;
      border-radius: 16px;
      background: var(--padDark);
      color: rgba(255,255,255,.92);
      font-weight: 1000;
      font-size: 18px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), 0 10px 18px rgba(0,0,0,.22);
    }

    .padBtn.small{
      width: 62px; height: 52px;
      border-radius: 14px;
      font-size: 16px;
      opacity:.98;
    }

    .padBtn.center{
      background: rgba(0,0,0,.30);
      color: rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.12);
    }

    /* Middle: Select / Start */
    .midKeys{
      display:grid;
      justify-items:center;
      gap: 10px;
      padding: 6px 8px;
    }
    .midRow{ display:flex; gap: 12px; }
    .pillKey{
      width: 86px; height: 36px;
      border-radius: 999px;
      background: rgba(0,0,0,.12);
      border: 1px solid rgba(0,0,0,.14);
      font-weight: 1000;
      color: rgba(0,0,0,.70);
    }
    .keyLabel{
      font-size: 11px;
      color: rgba(0,0,0,.55);
      font-weight: 900;
      text-align:center;
      margin-top: -2px;
    }

    /* ABXY */
    .abxy{
      display:grid;
      justify-items:center;
      gap:8px;
    }
    .abxyRow{display:flex; gap:10px}
    .colorBtn{
      width: 64px; height: 64px;
      border-radius: 999px;
      font-weight: 1000;
      font-size: 20px;
      color: rgba(0,0,0,.68);
      box-shadow: inset 0 0 0 3px rgba(255,255,255,.35), 0 12px 22px rgba(0,0,0,.22);
    }
    .A{ background: var(--A); color: rgba(255,255,255,.92); }
    .B{ background: var(--B); }
    .X{ background: var(--X); color: rgba(255,255,255,.92); }
    .Y{ background: var(--Y); }

    /* Small footer hint (very small, optional) */
    .padHint{
      margin-top: 10px;
      text-align:center;
      font-size: 12px;
      color: rgba(0,0,0,.55);
      font-weight: 800;
    }

    @media (max-width: 420px){
      .padBtn{ width: 64px; height: 56px; }
      .colorBtn{ width: 60px; height: 60px; }
      .pillKey{ width: 78px; }
      .padBody{ padding: 12px; border-radius: 24px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="screenWrap">
      <div class="screenFrame">
        <canvas id="cv"></canvas>
      </div>
    </div>

    <div class="pad">
      <div class="padBody">
        <div class="padTop">
          <button class="btn shoulder" data-k="L">L</button>
          <button class="btn shoulder" data-k="R">R</button>
        </div>

        <div class="padMain">
          <!-- D-Pad -->
          <div class="dpad">
            <button class="btn padBtn" data-k="UP">‚ñ≤</button>
            <div class="dpadMid">
              <button class="btn padBtn" data-k="LEFT">‚óÄ</button>
              <button class="btn padBtn center small" data-k="HM">HM</button>
              <button class="btn padBtn" data-k="RIGHT">‚ñ∂</button>
            </div>
            <button class="btn padBtn" data-k="DOWN">‚ñº</button>
          </div>

          <!-- Select / Start -->
          <div class="midKeys">
            <div class="midRow">
              <div>
                <button class="btn pillKey" data-k="SELECT">SELECT</button>
                <div class="keyLabel">LANG</div>
              </div>
              <div>
                <button class="btn pillKey" data-k="START">START</button>
                <div class="keyLabel">PAUSE</div>
              </div>
            </div>
          </div>

          <!-- ABXY -->
          <div class="abxy">
            <div class="abxyRow">
              <button class="btn colorBtn X" data-k="X">X</button>
            </div>
            <div class="abxyRow">
              <button class="btn colorBtn Y" data-k="Y">Y</button>
              <button class="btn colorBtn A" data-k="A">A</button>
            </div>
            <div class="abxyRow">
              <button class="btn colorBtn B" data-k="B">B</button>
            </div>
          </div>
        </div>

        <div class="padHint">HM GAME üéÆ ‚Äî A: Select ‚Ä¢ START: Pause ‚Ä¢ SELECT: Arabic/English ‚Ä¢ L: Restart ‚Ä¢ R: Menu</div>
      </div>
    </div>
  </div>
<script>
(() => {
  "use strict";

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { alpha:false });

  // ---------- Helpers ----------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now();
  const pad2=n=>String(n).padStart(2,"0");
  const DPR=()=>Math.max(1, Math.floor(window.devicePixelRatio||1));

  function resize(){
    const r=cv.getBoundingClientRect();
    const d=DPR();
    const w=Math.floor(r.width*d), h=Math.floor(r.height*d);
    if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; }
  }
  window.addEventListener("resize", resize);

  function fmtTime(ms){
    const s=Math.floor(ms/1000);
    const m=Math.floor(s/60);
    return `${pad2(m)}:${pad2(s%60)}`;
  }

  // ---------- Language ----------
  const LANG_KEY="HM_LANG";
  let lang=localStorage.getItem(LANG_KEY)||"ar"; // default Arabic like your screenshots
  const T={
    ar:{
      title:"HM GAME",
      menuQ:"‚ùì ÿ£Ÿä ŸÑÿπÿ®ÿ© ÿ™ÿ±ŸäÿØÿü",
      menuHint:"ÿßÿ≥ÿ™ÿπŸÖŸÑ ‚óÄ ‚ñ∂ ŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÑÿπÿ®ÿ© ÿ´ŸÖ ÿßÿ∂ÿ∫ÿ∑ A ŸÑŸÑÿ®ÿØÿ°",
      snake:"üêç ÿßŸÑÿ´ÿπÿ®ÿßŸÜ",
      bounce:"üî¥ ÿ®ÿßŸàŸÜÿ≥",
      start:"ÿßÿ∂ÿ∫ÿ∑ A ŸÑŸÑÿ®ÿØÿ°",
      paused:"‚è∏Ô∏è ŸÖÿ™ŸàŸÇŸÅ ŸÖÿ§ŸÇÿ™ÿßŸã",
      win:"üèÜ ŸÑŸÇÿØ ÿ±ÿ®ÿ≠ÿ™!",
      over:"üòµ ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©",
      again:"A: ÿ•ÿπÿßÿØÿ©",
      back:"R: ÿßŸÑŸÇÿßÿ¶ŸÖÿ©",
      close:"B: ÿ•ÿ∫ŸÑÿßŸÇ",
    },
    en:{
      title:"HM GAME",
      menuQ:"‚ùì Which game do you want?",
      menuHint:"Use ‚óÄ ‚ñ∂ to choose, then press A to start",
      snake:"üêç Snake",
      bounce:"üî¥ Bounce",
      start:"Press A to start",
      paused:"‚è∏Ô∏è Paused",
      win:"üèÜ YOU WIN!",
      over:"üòµ Game Over",
      again:"A: Restart",
      back:"R: Menu",
      close:"B: Close",
    }
  };
  function toggleLang(){
    lang = (lang==="ar") ? "en" : "ar";
    localStorage.setItem(LANG_KEY, lang);
    document.documentElement.lang = lang;
    document.documentElement.dir  = (lang==="ar") ? "rtl" : "ltr";
  }
  toggleLang(); toggleLang(); // apply once without changing

  // ---------- Best scores ----------
  const BEST_KEY="HM_BEST";
  const bests=(()=>{try{return JSON.parse(localStorage.getItem(BEST_KEY)||"{}");}catch{return{};}})();
  const getBest=(k)=>bests[k]||0;
  const setBest=(k,v)=>{ if((bests[k]||0)<v){ bests[k]=v; localStorage.setItem(BEST_KEY,JSON.stringify(bests)); } };

  // ---------- Global state ----------
  const S={
    mode:"menu",     // menu | play | pause | result
    game:"snake",    // snake | bounce
    menuIdx:0,       // 0 snake, 1 bounce
    startedAt:0,
    time:0,
    score:0,
    best:0,

    // Snake stats
    apples:0,
    length:3,
    level:1,

    // Bounce stats
    lives:3,
    hoopsLeft:0,
    stage:1,
    deaths:0,

    resultType:"over", // over | win
    resultLines:[]
  };

  // ---------- Input (from controller) ----------
  const I={
    left:false,right:false,up:false,down:false,
    pressA:false,pressB:false,pressStart:false,pressSelect:false,pressL:false,pressR:false
  };

  function clearPresses(){
    I.pressA=I.pressB=I.pressStart=I.pressSelect=I.pressL=I.pressR=false;
  }

  // Buttons
  document.querySelectorAll("[data-k]").forEach(btn=>{
    const k=btn.dataset.k;

    // Hold keys
    const isDir = ["LEFT","RIGHT","UP","DOWN"].includes(k);

    btn.addEventListener("pointerdown",(e)=>{
      e.preventDefault();
      if(k==="LEFT") I.left=true;
      if(k==="RIGHT") I.right=true;
      if(k==="UP") I.up=true;
      if(k==="DOWN") I.down=true;
      if(!isDir){
        if(k==="A") I.pressA=true;
        if(k==="B") I.pressB=true;
        if(k==="START") I.pressStart=true;
        if(k==="SELECT") I.pressSelect=true;
        if(k==="L") I.pressL=true;
        if(k==="R") I.pressR=true;
      }
    });

    btn.addEventListener("pointerup",(e)=>{
      e.preventDefault();
      if(k==="LEFT") I.left=false;
      if(k==="RIGHT") I.right=false;
      if(k==="UP") I.up=false;
      if(k==="DOWN") I.down=false;
    });

    btn.addEventListener("pointercancel",(e)=>{
      if(k==="LEFT") I.left=false;
      if(k==="RIGHT") I.right=false;
      if(k==="UP") I.up=false;
      if(k==="DOWN") I.down=false;
    });
  });

  // Keyboard support (optional)
  window.addEventListener("keydown",(e)=>{
    const k=e.key.toLowerCase();
    if(k==="arrowleft"||k==="a") I.left=true;
    if(k==="arrowright"||k==="d") I.right=true;
    if(k==="arrowup"||k==="w") I.up=true;
    if(k==="arrowdown"||k==="s") I.down=true;

    if(k==="enter") I.pressA=true;
    if(k==="escape") I.pressB=true;
    if(k==="p") I.pressStart=true;
    if(k==="l") I.pressSelect=true;
  },{passive:true});

  window.addEventListener("keyup",(e)=>{
    const k=e.key.toLowerCase();
    if(k==="arrowleft"||k==="a") I.left=false;
    if(k==="arrowright"||k==="d") I.right=false;
    if(k==="arrowup"||k==="w") I.up=false;
    if(k==="arrowdown"||k==="s") I.down=false;
  },{passive:true});

  // ---------- Screen UI drawing (one status line only) ----------
  function statusLine(){
    const tm = fmtTime(S.time);
    if(S.mode==="menu"){
      return `HM GAME | ${lang==="ar" ? "ÿßÿÆÿ™ÿ± ŸÑÿπÿ®ÿ©" : "Choose Game"} | ${tm}`;
    }
    if(S.game==="snake"){
      const b=getBest("snake");
      return `HM GAME | Snake Lv ${S.level} | üçé${S.apples} Len ${S.length} | Score ${S.score} | Best ${b} | ${tm}`;
    } else {
      const b=getBest("bounce");
      return `HM GAME | Bounce Lv ${S.stage} | ‚ù§Ô∏è${S.lives} | üü°${S.hoopsLeft} | Score ${S.score} | Best ${b} | ${tm}`;
    }
  }

  function drawTopBar(){
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,.30)";
    ctx.fillRect(0,0,cv.width, Math.floor(cv.height*0.08));
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.font = `${Math.floor(cv.height*0.032)}px system-ui`;
    ctx.textAlign="left";
    ctx.textBaseline="middle";
    ctx.fillText(statusLine(), Math.floor(cv.width*0.02), Math.floor(cv.height*0.04));
    ctx.restore();
  }

  // ---------- Game switching ----------
  function resetCommon(){
    S.startedAt=now();
    S.time=0;
    S.score=0;
  }

  function goMenu(){
    S.mode="menu";
    S.menuIdx=0;
    S.game="snake";
    resetCommon();
  }

  function startGame(which){
    S.mode="play";
    S.game=which;
    resetCommon();
    if(which==="snake") Snake.init();
    else Bounce.init();
  }

  function togglePause(){
    if(S.mode==="play"){ S.mode="pause"; }
    else if(S.mode==="pause"){ S.mode="play"; }
  }

  function showResult(type, lines){
    S.mode="result";
    S.resultType=type; // "win"|"over"
    S.resultLines=lines;
    // best update
    setBest(S.game, S.score);
  }

  // ---------- Menu draw ----------
  function drawMenu(){
    ctx.fillStyle="#050b14";
    ctx.fillRect(0,0,cv.width,cv.height);

    drawTopBar();

    const y0 = cv.height*0.22;
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.textAlign="center";
    ctx.font=`${Math.floor(cv.width*0.09)}px system-ui`;
    ctx.fillText("HM GAME", cv.width/2, y0);

    ctx.font=`${Math.floor(cv.width*0.05)}px system-ui`;
    ctx.fillStyle="rgba(255,255,255,.78)";
    ctx.fillText(T[lang].menuQ, cv.width/2, y0 + cv.height*0.10);

    // options
    const opts=[T[lang].snake, T[lang].bounce];
    const baseY = y0 + cv.height*0.22;

    for(let i=0;i<2;i++){
      const is=i===S.menuIdx;
      const w=cv.width*0.70, h=cv.height*0.11;
      const x=cv.width*0.15, y=baseY + i*(h+cv.height*0.04);

      ctx.fillStyle = is ? "rgba(78,161,255,.18)" : "rgba(255,255,255,.06)";
      roundRect(x,y,w,h,18,true);

      ctx.strokeStyle = is ? "rgba(78,161,255,.60)" : "rgba(255,255,255,.14)";
      ctx.lineWidth = 2;
      roundRectStroke(x,y,w,h,18);

      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.font=`${Math.floor(cv.width*0.055)}px system-ui`;
      ctx.fillText(opts[i], cv.width/2, y + h*0.62);
    }

    ctx.fillStyle="rgba(255,255,255,.70)";
    ctx.font=`${Math.floor(cv.width*0.04)}px system-ui`;
    ctx.fillText(T[lang].menuHint, cv.width/2, cv.height*0.88);
    ctx.fillStyle="rgba(255,255,255,.60)";
    ctx.fillText(T[lang].start, cv.width/2, cv.height*0.93);
  }

  // ---------- Result panel drawn inside screen (transparent) ----------
  function drawResult(){
    // draw current game behind (frozen)
    if(S.game==="snake") Snake.draw();
    else Bounce.draw();

    drawTopBar();

    ctx.save();
    ctx.fillStyle="rgba(0,0,0,.40)";
    ctx.fillRect(0,0,cv.width,cv.height);

    const w=cv.width*0.78, h=cv.height*0.42;
    const x=(cv.width-w)/2, y=(cv.height-h)/2;

    ctx.fillStyle="rgba(20,26,40,.92)";
    roundRect(x,y,w,h,18,true);
    ctx.strokeStyle="rgba(255,255,255,.16)";
    ctx.lineWidth=2;
    roundRectStroke(x,y,w,h,18);

    ctx.textAlign="center";
    ctx.fillStyle="rgba(255,255,255,.95)";
    ctx.font=`${Math.floor(cv.width*0.06)}px system-ui`;
    ctx.fillText(S.resultType==="win" ? T[lang].win : T[lang].over, cv.width/2, y + h*0.20);

    ctx.font=`${Math.floor(cv.width*0.042)}px system-ui`;
    ctx.fillStyle="rgba(255,255,255,.78)";
    let yy = y + h*0.36;
    for(const line of S.resultLines){
      ctx.fillText(line, cv.width/2, yy);
      yy += cv.height*0.05;
    }

    ctx.fillStyle="rgba(255,255,255,.82)";
    ctx.font=`${Math.floor(cv.width*0.04)}px system-ui`;
    ctx.fillText(`${T[lang].again}   ‚Ä¢   ${T[lang].back}   ‚Ä¢   ${T[lang].close}`, cv.width/2, y + h*0.86);

    ctx.restore();
  }

  // ---------- Shapes ----------
  function roundRect(x,y,w,h,r,fill){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    if(fill) ctx.fill();
  }
  function roundRectStroke(x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    ctx.stroke();
  }

  // (Games are defined in next parts)
  const Snake={}, Bounce={};

  // ---------- Main loop ----------
  let last=now();
  function loop(){
    resize();
    const t=now();
    const dt=clamp((t-last)/1000, 0, 0.04);
    last=t;

    // time
    if(S.mode!=="menu"){ S.time = t - S.startedAt; }

    // controller global actions
    if(I.pressSelect){ toggleLang(); I.pressSelect=false; }
    if(I.pressStart){ togglePause(); I.pressStart=false; }
    if(I.pressL){ // restart
      if(S.mode==="play"||S.mode==="pause"||S.mode==="result"){
        startGame(S.game);
      }
      I.pressL=false;
    }
    if(I.pressR){ // menu
      goMenu();
      I.pressR=false;
    }

    // menu control
    if(S.mode==="menu"){
      if(I.left||I.right){
        if(I.left) S.menuIdx=0;
        if(I.right) S.menuIdx=1;
        S.game = (S.menuIdx===0) ? "snake" : "bounce";
      }
      if(I.pressA){
        startGame(S.menuIdx===0 ? "snake" : "bounce");
        I.pressA=false;
      }
      drawMenu();
      clearPresses();
      requestAnimationFrame(loop);
      return;
    }

    // result control
    if(S.mode==="result"){
      if(I.pressA){
        startGame(S.game);
        I.pressA=false;
      }
      if(I.pressB){
        // close => stay in menu for simplicity
        goMenu();
        I.pressB=false;
      }
      drawResult();
      clearPresses();
      requestAnimationFrame(loop);
      return;
    }

    // pause screen
    if(S.mode==="pause"){
      if(S.game==="snake") Snake.draw();
      else Bounce.draw();
      drawTopBar();

      // small pause label (transparent)
      ctx.fillStyle="rgba(0,0,0,.25)";
      const w=cv.width*0.55, h=cv.height*0.12;
      roundRect((cv.width-w)/2, cv.height*0.44, w, h, 16, true);
      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.textAlign="center";
      ctx.font=`${Math.floor(cv.width*0.05)}px system-ui`;
      ctx.fillText(T[lang].paused, cv.width/2, cv.height*0.51);

      clearPresses();
      requestAnimationFrame(loop);
      return;
    }

    // play
    if(S.mode==="play"){
      if(S.game==="snake") Snake.update(dt);
      else Bounce.update(dt);

      if(S.game==="snake") Snake.draw();
      else Bounce.draw();

      drawTopBar();
    }

    clearPresses();
    requestAnimationFrame(loop);
  }
// =================
  // üêç SNAKE
  // =================
  (function(){
    const GW=22, GH=16; // fits phone nicely
    let cell=16, ox=0, oy=0;

    let snake=[], dir={x:1,y:0};
    let food={x:10,y:8};
    let tick=0, speed=7;
    let alive=true;

    function layout(){
      const topBarH=Math.floor(cv.height*0.08);
      const pad= Math.floor(Math.min(cv.width,cv.height)*0.06);
      const usableW = cv.width - pad*2;
      const usableH = (cv.height - topBarH) - pad*2;

      cell = Math.max(10, Math.floor(Math.min(usableW/GW, usableH/GH)));
      ox = Math.floor((cv.width - cell*GW)/2);
      oy = Math.floor(topBarH + ( (cv.height-topBarH) - cell*GH )/2 );
    }

    function placeFood(){
      for(let i=0;i<2000;i++){
        const fx=(Math.random()*GW)|0;
        const fy=(Math.random()*GH)|0;
        if(!snake.some(p=>p.x===fx && p.y===fy)){ food={x:fx,y:fy}; return; }
      }
      food={x:1,y:1};
    }

    function init(){
      layout();
      snake=[
        {x:6,y:(GH/2)|0},
        {x:5,y:(GH/2)|0},
        {x:4,y:(GH/2)|0}
      ];
      dir={x:1,y:0};
      tick=0; speed=7; alive=true;

      S.score=0; S.apples=0; S.length=3; S.level=1;
      placeFood();
    }

    function setDir(nx,ny){
      // prevent direct reverse
      if(nx===-dir.x && ny===-dir.y) return;
      dir={x:nx,y:ny};
    }

    function step(){
      if(!alive) return;

      // dpad directions
      if(I.up) setDir(0,-1);
      else if(I.down) setDir(0,1);
      else if(I.left) setDir(-1,0);
      else if(I.right) setDir(1,0);

      const h=snake[0];
      const nx=h.x+dir.x, ny=h.y+dir.y;

      // wall
      if(nx<0||nx>=GW||ny<0||ny>=GH){ gameOver(); return; }
      // self
      if(snake.some((p,i)=>i>0 && p.x===nx && p.y===ny)){ gameOver(); return; }

      snake.unshift({x:nx,y:ny});

      if(nx===food.x && ny===food.y){
        S.score += 10;
        S.apples++;
        S.length=snake.length;

        S.level = 1 + Math.floor(S.apples/5);
        speed = 7 + (S.level-1)*1.2;

        placeFood();
        setBest("snake", S.score);
      }else{
        snake.pop();
        S.length=snake.length;
      }
    }

    function gameOver(){
      alive=false;
      setBest("snake", S.score);
      showResult("over", [
        (lang==="ar") ? `ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©: ${S.score}` : `Score: ${S.score}`,
        (lang==="ar") ? `ÿßŸÑÿ™ŸÅÿßÿ≠: ${S.apples}` : `Apples: ${S.apples}`,
        (lang==="ar") ? `ÿßŸÑÿ∑ŸàŸÑ: ${S.length}` : `Length: ${S.length}`,
        (lang==="ar") ? `ÿßŸÑŸàŸÇÿ™: ${fmtTime(S.time)}` : `Time: ${fmtTime(S.time)}`
      ]);
    }

    function update(dt){
      layout();
      tick += dt*speed;
      while(tick>=1){
        tick-=1;
        step();
        if(S.mode!=="play") break;
      }
    }

    function draw(){
      layout();
      // background
      ctx.fillStyle="#061025";
      ctx.fillRect(0,0,cv.width,cv.height);

      // board area (transparent look)
      ctx.fillStyle="rgba(255,255,255,.04)";
      roundRect(ox-10, oy-10, cell*GW+20, cell*GH+20, 18, true);

      // grid faint
      ctx.fillStyle="rgba(255,255,255,.025)";
      for(let y=0;y<=GH;y++){
        ctx.fillRect(ox, oy+y*cell, cell*GW, 1);
      }
      for(let x=0;x<=GW;x++){
        ctx.fillRect(ox+x*cell, oy, 1, cell*GH);
      }

      // food
      const fx=ox+food.x*cell+cell/2;
      const fy=oy+food.y*cell+cell/2;
      ctx.fillStyle="rgba(255,211,79,.95)";
      ctx.beginPath();
      ctx.arc(fx,fy, cell*0.24, 0, Math.PI*2);
      ctx.fill();

      // snake body
      for(let i=snake.length-1;i>=0;i--){
        const p=snake[i];
        const x=ox+p.x*cell, y=oy+p.y*cell;
        const inset=Math.floor(cell*0.12);
        const rr=Math.floor(cell*0.28);

        if(i===0){
          // head
          ctx.fillStyle="rgba(78,161,255,.95)";
          roundRect(x+inset, y+inset, cell-inset*2, cell-inset*2, rr, true);

          // eyes
          const ex1=x+cell*0.38, ex2=x+cell*0.62;
          const ey=y+cell*0.42;
          ctx.fillStyle="rgba(255,255,255,.92)";
          ctx.beginPath(); ctx.arc(ex1,ey, cell*0.07, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(ex2,ey, cell*0.07, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle="rgba(0,0,0,.65)";
          ctx.beginPath(); ctx.arc(ex1,ey, cell*0.035, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(ex2,ey, cell*0.035, 0, Math.PI*2); ctx.fill();
        } else {
          ctx.fillStyle="rgba(78,161,255,.70)";
          roundRect(x+inset, y+inset, cell-inset*2, cell-inset*2, rr, true);
        }
      }
    }

    Snake.init=init;
    Snake.update=update;
    Snake.draw=draw;
  })();
// =================
  // üî¥ BOUNCE (core rules)
  // =================
  (function(){
    const TILE=24;

    // # solid, . empty, o hoop, ^ spike, G gate, C checkpoint
    const LEVELS=[
      [
        "........................................",
        "........................................",
        ".............o.........................G",
        "............#####.......................",
        "........................................",
        "....o......................o............",
        "....###...........C......#####..........",
        "........................................",
        "..................^.....................",
        "############......^......#############..",
        "........................................",
        "..............o.........................",
        ".............#####......................",
        "........................................",
        "###############################.........",
      ],
      [
        "........................................",
        "........................................",
        "....o.............o....................G",
        "....###..........#####..................",
        "........................................",
        ".................^......................",
        "....o............^..........C....o......",
        "....###........#####...........#####....",
        "........................................",
        "..............o.........................",
        "............#####.......................",
        "........................................",
        "############.............#############..",
        "........................................",
        "###############################.........",
      ],
      [
        "........................................",
        "........................................",
        "....o..............o..................G.",
        "....###..........#####..................",
        "........................................",
        ".................^......................",
        "....o............^..........o...........",
        "....###........#####......#####.........",
        "....................C...................",
        "........................................",
        "..............o.........................",
        "............#####.......................",
        "........................................",
        "############.............#############..",
        "###############################.........",
      ]
    ];

    let map=[], W=0,H=0;
    let stage=0;
    let hoopsTotal=0;
    let respawn={x: TILE*2, y: TILE*2};

    const ball={x:0,y:0,vx:0,vy:0,r:11};

    let camX=0, camY=0;

    function loadStage(i, freshRun){
      stage=i;
      S.stage=i+1;

      map=LEVELS[i].map(r=>r.split(""));
      H=map.length; W=map[0].length;

      hoopsTotal=0;
      for(let y=0;y<H;y++)for(let x=0;x<W;x++) if(map[y][x]==="o") hoopsTotal++;

      S.hoopsLeft=hoopsTotal;

      // respawn resets each stage to start
      respawn={x:TILE*2, y:TILE*2};

      // ball reset
      ball.x=respawn.x; ball.y=respawn.y;
      ball.vx=0; ball.vy=0;

      if(freshRun){
        S.score=0;
        S.lives=3;      // core rule: starts with 3 lives Ó®Å2Ó®Ç
        S.deaths=0;
      }
    }

    function init(){
      loadStage(0, true);
    }

    function tileAt(tx,ty){
      if(ty<0||ty>=H||tx<0||tx>=W) return ".";
      return map[ty][tx];
    }
    function setTile(tx,ty,v){
      if(ty<0||ty>=H||tx<0||tx>=W) return;
      map[ty][tx]=v;
    }
    function isSolid(tx,ty){ return tileAt(tx,ty)==="#"; }

    function circleRect(cx,cy,cr, rx,ry,rw,rh){
      const nx=clamp(cx,rx,rx+rw);
      const ny=clamp(cy,ry,ry+rh);
      const dx=cx-nx, dy=cy-ny;
      return (dx*dx+dy*dy) <= cr*cr;
    }

    function collideSolids(cx,cy,cr){
      const L=( (cx-cr)/TILE )|0;
      const R=( (cx+cr)/TILE )|0;
      const Tt=( (cy-cr)/TILE )|0;
      const B=( (cy+cr)/TILE )|0;
      for(let ty=Tt;ty<=B;ty++){
        for(let tx=L;tx<=R;tx++){
          if(isSolid(tx,ty)){
            const rx=tx*TILE, ry=ty*TILE;
            if(circleRect(cx,cy,cr, rx,ry,TILE,TILE)) return true;
          }
        }
      }
      return false;
    }

    function resolve(){
      for(let i=0;i<24;i++){
        if(!collideSolids(ball.x,ball.y,ball.r)) break;
        ball.y -= 1;
        if(!collideSolids(ball.x,ball.y,ball.r)){ ball.vy=Math.min(ball.vy,0); break; }
        ball.y += 1;
        ball.x += (ball.vx>=0)? -1 : 1;
        if(!collideSolids(ball.x,ball.y,ball.r)){ ball.vx=0; break; }
        ball.y -= 1;
      }
    }

    function loseLife(reason){
      S.lives--;
      S.deaths++;

      if(S.lives<=0){
        setBest("bounce", S.score);
        showResult("over", [
          (lang==="ar") ? `ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©: ${S.stage}` : `Level: ${S.stage}`,
          (lang==="ar") ? `ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©: ${S.score}` : `Score: ${S.score}`,
          (lang==="ar") ? `ŸÖÿ±ÿßÿ™ ÿßŸÑÿÆÿ≥ÿßÿ±ÿ©: ${S.deaths}` : `Deaths: ${S.deaths}`,
          (lang==="ar") ? `ÿßŸÑŸàŸÇÿ™: ${fmtTime(S.time)}` : `Time: ${fmtTime(S.time)}`
        ]);
        return;
      }

      // respawn at checkpoint
      ball.x=respawn.x; ball.y=respawn.y;
      ball.vx=0; ball.vy=0;
    }

    function update(dt){
      // movement (left/right like old phones)
      const accel=1200, maxVx=520, gravity=1650, drag=0.995, bounce=0.72;

      if(I.left) ball.vx -= accel*dt;
      if(I.right) ball.vx += accel*dt;
      ball.vx = clamp(ball.vx, -maxVx, maxVx);

      ball.vy += gravity*dt;

      ball.x += ball.vx*dt;
      ball.y += ball.vy*dt;

      ball.vx *= Math.pow(drag, dt*60);
      ball.vy *= Math.pow(drag, dt*60);

      if(collideSolids(ball.x,ball.y,ball.r)){
        // simple bounce
        ball.vy = -Math.abs(ball.vy)*bounce;
        resolve();
      }

      // fall -> lose
      if(ball.y > H*TILE + 400){
        loseLife("fall");
        return;
      }

      // interactions around ball
      interact();

      // camera follow
      const viewW=cv.width, viewH=cv.height;
      const mapW=W*TILE, mapH=H*TILE;

      camX = clamp(ball.x - viewW*0.50, 0, Math.max(0, mapW-viewW));
      camY = clamp(ball.y - viewH*0.55, 0, Math.max(0, mapH-viewH));
    }

    function interact(){
      const tx=(ball.x/TILE)|0, ty=(ball.y/TILE)|0;

      for(let y=ty-1;y<=ty+1;y++){
        for(let x=tx-1;x<=tx+1;x++){
          const t=tileAt(x,y);
          const rx=x*TILE, ry=y*TILE;

          // hoop collectible
          if(t==="o"){
            if(circleRect(ball.x,ball.y,ball.r, rx+6,ry+6,TILE-12,TILE-12)){
              setTile(x,y,".");
              S.score += 50;
              S.hoopsLeft = Math.max(0, S.hoopsLeft-1);
              setBest("bounce", S.score);
            }
          }

          // spike
          if(t==="^"){
            if(circleRect(ball.x,ball.y,ball.r, rx,ry,TILE,TILE)){
              loseLife("spike");
              return;
            }
          }

          // checkpoint
          if(t==="C"){
            if(circleRect(ball.x,ball.y,ball.r, rx,ry,TILE,TILE)){
              respawn={x: rx+TILE/2, y: ry+TILE/2};
              // make it consumed visually
              setTile(x,y,".");
            }
          }

          // gate: locked until hoopsLeft == 0 (core rule) Ó®Å3Ó®Ç
          if(t==="G"){
            if(circleRect(ball.x,ball.y,ball.r, rx,ry,TILE,TILE)){
              if(S.hoopsLeft<=0){
                // next stage or win
                if(stage+1 < LEVELS.length){
                  loadStage(stage+1, false);
                }else{
                  setBest("bounce", S.score);
                  showResult("win", [
                    (lang==="ar") ? `ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©: ${S.score}` : `Score: ${S.score}`,
                    (lang==="ar") ? `ŸÖÿ±ÿßÿ™ ÿßŸÑÿÆÿ≥ÿßÿ±ÿ©: ${S.deaths}` : `Deaths: ${S.deaths}`,
                    (lang==="ar") ? `ÿßŸÑŸàŸÇÿ™: ${fmtTime(S.time)}` : `Time: ${fmtTime(S.time)}`
                  ]);
                }
              }else{
                // gate locked: tiny penalty or none
              }
            }
          }
        }
      }
    }

    function draw(){
      // sky
      ctx.fillStyle="#4aaed6";
      ctx.fillRect(0,0,cv.width,cv.height);

      // draw tiles in view
      const startTx=(camX/TILE)|0;
      const endTx=((camX+cv.width)/TILE+1)|0;
      const startTy=(camY/TILE)|0;
      const endTy=((camY+cv.height)/TILE+1)|0;

      for(let ty=startTy;ty<endTy;ty++){
        for(let tx=startTx;tx<endTx;tx++){
          const t=tileAt(tx,ty);
          const x=tx*TILE - camX;
          const y=ty*TILE - camY;

          if(t==="#") brick(x,y);
          else if(t==="o") hoop(x,y);
          else if(t==="^") spike(x,y);
          else if(t==="G") gate(x,y, S.hoopsLeft<=0);
          else if(t==="C") checkpoint(x,y);
        }
      }

      // ball
      drawBall(ball.x-camX, ball.y-camY, ball.r);

      // small helper text inside game (transparent)
      ctx.fillStyle="rgba(0,0,0,.20)";
      ctx.font=`${Math.floor(cv.height*0.03)}px system-ui`;
      ctx.textAlign="left";
      ctx.fillText(`Hoops: ${S.hoopsLeft}`, 14, Math.floor(cv.height*0.13));
    }

    function drawBall(x,y,r){
      ctx.fillStyle="rgba(0,0,0,.18)";
      ctx.beginPath();
      ctx.ellipse(x, y + r*0.85, r*1.05, r*0.35, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle="#e83535";
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();

      ctx.fillStyle="rgba(255,255,255,.30)";
      ctx.beginPath();
      ctx.arc(x-r*0.35,y-r*0.35,r*0.35,0,Math.PI*2);
      ctx.fill();
    }

    function brick(x,y){
      ctx.fillStyle="#b55a2d";
      ctx.fillRect(x,y,TILE,TILE);
      ctx.fillStyle="rgba(255,255,255,.10)";
      ctx.fillRect(x+2,y+2,TILE-4,5);
      ctx.strokeStyle="#8f3d1f";
      ctx.lineWidth=2;
      ctx.strokeRect(x+1,y+1,TILE-2,TILE-2);
    }

    function hoop(x,y){
      ctx.strokeStyle="rgba(255,211,79,.95)";
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(x+TILE/2,y+TILE/2,TILE*0.28,0,Math.PI*2);
      ctx.stroke();
    }

    function spike(x,y){
      ctx.fillStyle="rgba(10,16,28,.92)";
      ctx.beginPath();
      ctx.moveTo(x, y+TILE);
      ctx.lineTo(x+TILE*0.25, y+TILE*0.35);
      ctx.lineTo(x+TILE*0.5, y+TILE);
      ctx.lineTo(x+TILE*0.75, y+TILE*0.35);
      ctx.lineTo(x+TILE, y+TILE);
      ctx.closePath();
      ctx.fill();
    }

    function checkpoint(x,y){
      ctx.fillStyle="rgba(255,255,255,.18)";
      roundRect(x+4,y+4,TILE-8,TILE-8,7,true);
      ctx.strokeStyle="rgba(255,255,255,.55)";
      ctx.lineWidth=2;
      roundRectStroke(x+4,y+4,TILE-8,TILE-8,7);
      ctx.fillStyle="rgba(255,255,255,.85)";
      ctx.font=`${Math.floor(TILE*0.55)}px system-ui`;
      ctx.textAlign="center";
      ctx.fillText("C", x+TILE/2, y+TILE*0.73);
    }

    function gate(x,y,open){
      ctx.fillStyle=open ? "rgba(255,255,255,.22)" : "rgba(0,0,0,.20)";
      roundRect(x+2,y+2,TILE-4,TILE-4,7,true);

      ctx.strokeStyle=open ? "rgba(255,255,255,.92)" : "rgba(255,255,255,.35)";
      ctx.lineWidth=2;
      roundRectStroke(x+4,y+4,TILE-8,TILE-8,6);

      ctx.fillStyle=open ? "rgba(255,255,255,.92)" : "rgba(255,255,255,.70)";
      ctx.font=`${Math.floor(TILE*0.55)}px system-ui`;
      ctx.textAlign="center";
      ctx.fillText(open ? "‚úì" : "G", x+TILE/2, y+TILE*0.73);
    }

    Bounce.init=init;
    Bounce.update=update;
    Bounce.draw=draw;
  })();
// Start from menu
  goMenu();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
