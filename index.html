<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#070d18" />
  <title>HM GAME</title>

  <style>
    :root{
      --bg:#070d18;
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --line: rgba(255,255,255,.14);

      --padBase: rgba(240,240,240,.92);
      --padDark: rgba(22,24,30,.92);
      --padShadow: rgba(0,0,0,.35);

      --A:#e43b3b;
      --B:#f0c535;
      --X:#2d71ff;
      --Y:#2ecc71;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 900px at 70% 15%, #1b2a55, var(--bg));
      color:var(--txt);
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* ÿ™ŸÇÿ≥ŸäŸÖ ŸÖÿ∂ÿ®Ÿàÿ∑: ÿßŸÑÿ£ÿπŸÑŸâ = ÿ¥ÿßÿ¥ÿ©ÿå ÿßŸÑÿ£ÿ≥ŸÅŸÑ = ÿ£ÿ≤ÿ±ÿßÿ± */
    .app{
      height: 100dvh;
      display:grid;
      grid-template-rows: 1fr auto;
    }

    .screenWrap{
      padding: 10px;
      padding-top: calc(10px + env(safe-area-inset-top));
      min-height: 0;
    }

    .screenFrame{
      height: 100%;
      min-height: 0;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      box-shadow: 0 20px 70px rgba(0,0,0,.40);
      overflow:hidden;
    }

    canvas#cv{
      width:100%;
      height:100%;
      display:block;
      background:#050b14;
    }

    /* ÿ£ŸáŸÖ ÿ™ÿπÿØŸäŸÑ: ÿÆŸÑŸëŸäÿ™ ŸäÿØ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ£ŸÇŸÑÿå ÿπÿ¥ÿßŸÜ ÿßŸÑÿ¥ÿßÿ¥ÿ© ÿ£ŸÉÿ®ÿ± */
    .pad{
      padding: 12px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      background: rgba(0,0,0,.14);
      height: clamp(210px, 32dvh, 310px);
    }

    .padBody{
      height: 100%;
      max-width: 900px;
      margin: 0 auto;
      border-radius: 26px;
      border: 1px solid rgba(255,255,255,.10);
      background: var(--padBase);
      box-shadow: 0 16px 60px var(--padShadow);
      padding: 14px;
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }

    .padBody:before{
      content:"";
      position:absolute; inset:-40% -20% auto -20%;
      height: 70%;
      transform: rotate(-10deg);
      background: rgba(255,255,255,.22);
      pointer-events:none;
    }

    .padTop{ display:flex; justify-content:space-between; gap:10px; z-index:1; }
    .shoulder{
      flex:1 1 0;
      border-radius: 16px;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(0,0,0,.12);
      padding: 10px 12px;
      font-weight: 1000;
      color: rgba(0,0,0,.70);
      user-select:none;
    }

    .padMain{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:center;
      gap: 14px;
      z-index:1;
    }

    .btn{
      border:none;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      -webkit-user-select:none;
    }
    .btn:active{ transform: translateY(1px); }

    /* D-Pad */
    .dpad{ display:grid; justify-items:center; gap:8px; }
    .dpadMid{ display:flex; gap:8px; align-items:center; }

    .padBtn{
      width: 62px; height: 54px;
      border-radius: 16px;
      background: var(--padDark);
      color: rgba(255,255,255,.92);
      font-weight: 1000;
      font-size: 18px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), 0 10px 18px rgba(0,0,0,.22);
    }
    .padBtn.center{
      background: rgba(0,0,0,.28);
      color: rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.12);
    }

    /* Select/Start */
    .midKeys{ display:grid; justify-items:center; gap: 10px; z-index:1; }
    .midRow{ display:flex; gap: 12px; }
    .pillKey{
      width: 82px; height: 36px;
      border-radius: 999px;
      background: rgba(0,0,0,.12);
      border: 1px solid rgba(0,0,0,.14);
      font-weight: 1000;
      color: rgba(0,0,0,.70);
    }
    .keyLabel{
      font-size: 11px;
      color: rgba(0,0,0,.55);
      font-weight: 900;
      text-align:center;
      margin-top: 2px;
    }

    /* ABXY */
    .abxy{ display:grid; justify-items:center; gap:8px; z-index:1; }
    .abxyRow{ display:flex; gap:10px; }
    .colorBtn{
      width: 58px; height: 58px;
      border-radius: 999px;
      font-weight: 1000;
      font-size: 20px;
      color: rgba(0,0,0,.70);
      box-shadow: inset 0 0 0 3px rgba(255,255,255,.35), 0 12px 22px rgba(0,0,0,.22);
    }
    .A{ background: var(--A); color: rgba(255,255,255,.92); }
    .B{ background: var(--B); }
    .X{ background: var(--X); color: rgba(255,255,255,.92); }
    .Y{ background: var(--Y); }

    .padHint{
      z-index:1;
      text-align:center;
      font-size: 12px;
      color: rgba(0,0,0,.55);
      font-weight: 900;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      padding: 0 6px;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="screenWrap">
      <div class="screenFrame">
        <canvas id="cv"></canvas>
      </div>
    </div>

    <div class="pad">
      <div class="padBody">
        <div class="padTop">
          <button class="btn shoulder" data-k="L">L</button>
          <button class="btn shoulder" data-k="R">R</button>
        </div>

        <div class="padMain">
          <div class="dpad">
            <button class="btn padBtn" data-k="UP">‚ñ≤</button>
            <div class="dpadMid">
              <button class="btn padBtn" data-k="LEFT">‚óÄ</button>
              <button class="btn padBtn center" data-k="HM">HM</button>
              <button class="btn padBtn" data-k="RIGHT">‚ñ∂</button>
            </div>
            <button class="btn padBtn" data-k="DOWN">‚ñº</button>
          </div>

          <div class="midKeys">
            <div class="midRow">
              <div>
                <button class="btn pillKey" data-k="SELECT">SELECT</button>
                <div class="keyLabel">LANG</div>
              </div>
              <div>
                <button class="btn pillKey" data-k="START">START</button>
                <div class="keyLabel">PAUSE</div>
              </div>
            </div>
          </div>

          <div class="abxy">
            <div class="abxyRow"><button class="btn colorBtn X" data-k="X">X</button></div>
            <div class="abxyRow">
              <button class="btn colorBtn Y" data-k="Y">Y</button>
              <button class="btn colorBtn A" data-k="A">A</button>
            </div>
            <div class="abxyRow"><button class="btn colorBtn B" data-k="B">B</button></div>
          </div>
        </div>

        <div class="padHint">
          HM GAME üéÆ ‚Äî A: Select/Start ‚Ä¢ START: Pause ‚Ä¢ SELECT: Arabic/English ‚Ä¢ L: Restart ‚Ä¢ R: Menu
        </div>
      </div>
    </div>
  </div>
<script>
(() => {
  "use strict";

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { alpha:false });

  // ---- IMPORTANT: draw in CSS pixels, upscale by DPR for crispness
  let W=0, H=0, D=1; // CSS width/height + DPR
  function resize(){
    const r=cv.getBoundingClientRect();
    D = Math.max(1, window.devicePixelRatio || 1);
    W = r.width;
    H = r.height;

    cv.width  = Math.floor(W * D);
    cv.height = Math.floor(H * D);

    // All drawing coordinates now use CSS pixels
    ctx.setTransform(D,0,0,D,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener("resize", resize);

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now();
  const pad2=n=>String(n).padStart(2,"0");
  const fmtTime=(ms)=>{
    const s=Math.floor(ms/1000);
    return `${pad2(Math.floor(s/60))}:${pad2(s%60)}`;
  };

  // ---- language
  const LANG_KEY="HM_LANG_V3";
  let lang=localStorage.getItem(LANG_KEY) || "ar";
  const T={
    ar:{
      choose:"ÿßÿÆÿ™ÿ± ŸÑÿπÿ®ÿ©",
      q:"‚ùì ÿ£Ÿä ŸÑÿπÿ®ÿ© ÿ™ÿ±ŸäÿØÿü",
      hint1:"ÿßÿ≥ÿ™ÿπŸÖŸÑ ‚óÄ ‚ñ∂ ŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÑÿπÿ®ÿ© ÿ´ŸÖ ÿßÿ∂ÿ∫ÿ∑ A ŸÑŸÑÿ®ÿØÿ°",
      hint2:"SELECT ŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑÿ∫ÿ©",
      snake:"üêç ÿßŸÑÿ´ÿπÿ®ÿßŸÜ",
      bounce:"üî¥ ÿ®ÿßŸàŸÜÿ≥",
      paused:"‚è∏Ô∏è ŸÖÿ™ŸàŸÇŸÅ ŸÖÿ§ŸÇÿ™ÿßŸã",
      win:"üèÜ ŸÑŸÇÿØ ÿ±ÿ®ÿ≠ÿ™!",
      over:"üòµ ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©",
      score:"ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©",
      best:"ÿßŸÑÿ£ŸÅÿ∂ŸÑ",
      time:"ÿßŸÑŸàŸÇÿ™",
      apples:"ÿ™ŸÅÿßÿ≠",
      len:"ÿßŸÑÿ∑ŸàŸÑ",
      lives:"ÿ≠Ÿäÿßÿ©",
      hoops:"ÿ≠ŸÑŸÇÿßÿ™",
      level:"ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ",
      restart:"A: ÿ•ÿπÿßÿØÿ©",
      menu:"R: ÿßŸÑŸÇÿßÿ¶ŸÖÿ©",
      close:"B: ÿ•ÿ∫ŸÑÿßŸÇ",
      locked:"ÿßŸÑÿ®ÿßÿ® ŸÖŸÇŸÅŸàŸÑ! ÿßÿ¨ŸÖÿπ ŸÉŸÑ ÿßŸÑÿ≠ŸÑŸÇÿßÿ™ üü°",
    },
    en:{
      choose:"Choose Game",
      q:"‚ùì Which game do you want?",
      hint1:"Use ‚óÄ ‚ñ∂ to choose, then press A to start",
      hint2:"SELECT to change language",
      snake:"üêç Snake",
      bounce:"üî¥ Bounce",
      paused:"‚è∏Ô∏è Paused",
      win:"üèÜ YOU WIN!",
      over:"üòµ Game Over",
      score:"Score",
      best:"Best",
      time:"Time",
      apples:"Apples",
      len:"Len",
      lives:"Lives",
      hoops:"Hoops",
      level:"Level",
      restart:"A: Restart",
      menu:"R: Menu",
      close:"B: Close",
      locked:"Gate locked! Collect all hoops üü°",
    }
  };

  function applyLang(){
    document.documentElement.lang = lang;
    document.documentElement.dir  = (lang==="ar") ? "rtl" : "ltr";
  }
  function toggleLang(){
    lang = (lang==="ar") ? "en" : "ar";
    localStorage.setItem(LANG_KEY, lang);
    applyLang();
  }
  applyLang();

  // ---- best
  const BEST_KEY="HM_BEST_V3";
  const bests=(()=>{ try{return JSON.parse(localStorage.getItem(BEST_KEY)||"{}");}catch{return{};} })();
  const getBest=(k)=>bests[k]||0;
  const setBest=(k,v)=>{ if((bests[k]||0)<v){ bests[k]=v; localStorage.setItem(BEST_KEY,JSON.stringify(bests)); } };

  // ---- state
  const S={
    mode:"menu", game:"snake", menuIdx:0,
    score:0,
    playMs:0, lastRunAt:0,
    // snake
    apples:0, len:3, level:1,
    // bounce
    lives:3, hoopsLeft:0, stage:1, deaths:0,
    // overlays
    resultType:"over", resultLines:[],
    toastText:"", toastUntil:0
  };

  function startClock(){ S.lastRunAt = now(); }
  function stopClock(){
    const t=now();
    if(S.lastRunAt) S.playMs += (t - S.lastRunAt);
    S.lastRunAt = 0;
  }
  function timeMs(){
    if(S.mode==="play" && S.lastRunAt) return S.playMs + (now() - S.lastRunAt);
    return S.playMs;
  }

  function toast(msg){
    S.toastText = msg;
    S.toastUntil = now() + 1200;
  }

  // ---- input (hold + edge)
  const hold={left:false,right:false,up:false,down:false};
  const jp={A:false,B:false,START:false,SELECT:false,L:false,R:false,LEFT:false,RIGHT:false,UP:false,DOWN:false};

  function setHold(key, val){
    if(hold[key]===val) return;
    hold[key]=val;
    if(val){
      const K=key.toUpperCase();
      if(K in jp) jp[K]=true;
    }
  }
  function clearJP(){ for(const k in jp) jp[k]=false; }

  document.querySelectorAll("[data-k]").forEach(btn=>{
    const k=btn.dataset.k;

    btn.addEventListener("pointerdown",(e)=>{
      e.preventDefault();

      if(k==="LEFT") setHold("left", true);
      if(k==="RIGHT") setHold("right", true);
      if(k==="UP") setHold("up", true);
      if(k==="DOWN") setHold("down", true);

      if(k==="A") jp.A=true;
      if(k==="B") jp.B=true;
      if(k==="START") jp.START=true;
      if(k==="SELECT") jp.SELECT=true;
      if(k==="L") jp.L=true;
      if(k==="R") jp.R=true;
    });

    const off=()=>{
      if(k==="LEFT") setHold("left", false);
      if(k==="RIGHT") setHold("right", false);
      if(k==="UP") setHold("up", false);
      if(k==="DOWN") setHold("down", false);
    };

    btn.addEventListener("pointerup",(e)=>{ e.preventDefault(); off(); });
    btn.addEventListener("pointercancel", off);
    btn.addEventListener("pointerleave", off);
  });

  // ---- canvas helpers
  function rr(x,y,w,h,r,fill){
    const rad=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rad,y);
    ctx.arcTo(x+w,y,x+w,y+h,rad);
    ctx.arcTo(x+w,y+h,x,y+h,rad);
    ctx.arcTo(x,y+h,x,y,rad);
    ctx.arcTo(x,y,x+w,y,rad);
    ctx.closePath();
    if(fill) ctx.fill(); else ctx.stroke();
  }

  function ellipsize(text, maxW){
    if(ctx.measureText(text).width <= maxW) return text;
    let s=text;
    while(s.length>3 && ctx.measureText(s+"‚Ä¶").width > maxW) s=s.slice(0,-1);
    return s+"‚Ä¶";
  }

  function topBarH(){ return clamp(H*0.060, 26, 40); }

  function drawTopBar(){
    const h=topBarH();
    ctx.fillStyle="rgba(0,0,0,.34)";
    ctx.fillRect(0,0,W,h);

    const fontSize = clamp(h*0.55, 12, 18);
    ctx.font = `${fontSize}px system-ui`;
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.textBaseline="middle";

    const tm=fmtTime(timeMs());
    let line="";

    if(S.mode==="menu"){
      line = `HM GAME | ${T[lang].choose} | ${tm}`;
    }else if(S.game==="snake"){
      line = `HM GAME | Snake ${T[lang].level} ${S.level} | üçé${S.apples} ${T[lang].len} ${S.len} | ${T[lang].score} ${S.score} | ${T[lang].best} ${getBest("snake")} | ${tm}`;
    }else{
      line = `HM GAME | Bounce ${T[lang].level} ${S.stage} | ‚ù§Ô∏è${S.lives} | üü°${S.hoopsLeft} | ${T[lang].score} ${S.score} | ${T[lang].best} ${getBest("bounce")} | ${tm}`;
    }

    const margin = W*0.02;
    const maxW = W - margin*2;
    line = ellipsize(line, maxW);

    if(lang==="ar"){
      ctx.textAlign="right";
      ctx.fillText(line, W - margin, h/2);
    }else{
      ctx.textAlign="left";
      ctx.fillText(line, margin, h/2);
    }

    return h;
  }

  // ---- navigation
  function goMenu(){
    S.mode="menu";
    S.menuIdx=0;
    S.game="snake";
    S.score=0;
    S.playMs=0;
    S.lastRunAt=0;
    S.toastText="";
    S.toastUntil=0;
  }

  function startGame(game){
    S.mode="play";
    S.game=game;
    S.score=0;
    S.playMs=0;
    startClock();
    if(game==="snake") Snake.init();
    else Bounce.init();
  }

  function togglePause(){
    if(S.mode==="play"){ S.mode="pause"; stopClock(); }
    else if(S.mode==="pause"){ S.mode="play"; startClock(); }
  }

  function showResult(type, lines){
    S.mode="result";
    stopClock();
    S.resultType=type;
    S.resultLines=lines;
    setBest(S.game, S.score);
  }
function drawMenu(){
    ctx.fillStyle="#050b14";
    ctx.fillRect(0,0,W,H);
    const topH=drawTopBar();

    const titleSize = clamp(W*0.10, 26, 52);
    const qSize     = clamp(W*0.055, 16, 30);
    const optSize   = clamp(W*0.055, 16, 28);
    const hintSize  = clamp(W*0.040, 12, 20);

    const midTop = topH + (H-topH)*0.20;

    ctx.textAlign="center";
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.font=`${titleSize}px system-ui`;
    ctx.fillText("HM GAME", W/2, midTop);

    ctx.fillStyle="rgba(255,255,255,.78)";
    ctx.font=`${qSize}px system-ui`;
    ctx.fillText(T[lang].q, W/2, midTop + (H-topH)*0.10);

    const opts=[T[lang].snake, T[lang].bounce];
    const cardW=W*0.78;
    const cardH=clamp((H-topH)*0.12, 48, 86);
    const startY=midTop + (H-topH)*0.20;

    for(let i=0;i<2;i++){
      const x=(W-cardW)/2;
      const y=startY + i*(cardH + (H-topH)*0.05);
      const active=(i===S.menuIdx);

      ctx.fillStyle= active ? "rgba(78,161,255,.18)" : "rgba(255,255,255,.06)";
      rr(x,y,cardW,cardH,18,true);
      ctx.strokeStyle= active ? "rgba(78,161,255,.60)" : "rgba(255,255,255,.14)";
      ctx.lineWidth=2;
      rr(x,y,cardW,cardH,18,false);

      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.font=`${optSize}px system-ui`;
      ctx.fillText(opts[i], W/2, y + cardH*0.64);
    }

    const hintY = topH + (H-topH)*0.86;
    ctx.fillStyle="rgba(255,255,255,.70)";
    ctx.font=`${hintSize}px system-ui`;
    ctx.fillText(T[lang].hint1, W/2, hintY);
    ctx.fillStyle="rgba(255,255,255,.60)";
    ctx.fillText(T[lang].hint2, W/2, hintY + hintSize*1.45);
  }

  function drawResult(){
    if(S.game==="snake") Snake.draw();
    else Bounce.draw();
    drawTopBar();

    ctx.fillStyle="rgba(0,0,0,.42)";
    ctx.fillRect(0,0,W,H);

    const w=W*0.82, h=H*0.42;
    const x=(W-w)/2, y=(H-h)/2;

    ctx.fillStyle="rgba(16,22,36,.92)";
    rr(x,y,w,h,18,true);
    ctx.strokeStyle="rgba(255,255,255,.16)";
    ctx.lineWidth=2;
    rr(x,y,w,h,18,false);

    const titleSize=clamp(W*0.060, 18, 32);
    const lineSize =clamp(W*0.045, 14, 24);
    const footSize =clamp(W*0.040, 12, 20);

    ctx.textAlign="center";
    ctx.fillStyle="rgba(255,255,255,.95)";
    ctx.font=`${titleSize}px system-ui`;
    ctx.fillText(S.resultType==="win" ? T[lang].win : T[lang].over, W/2, y + h*0.22);

    ctx.fillStyle="rgba(255,255,255,.80)";
    ctx.font=`${lineSize}px system-ui`;
    let yy = y + h*0.40;
    for(const line of S.resultLines){
      ctx.fillText(line, W/2, yy);
      yy += lineSize*1.35;
    }

    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font=`${footSize}px system-ui`;
    ctx.fillText(`${T[lang].restart}  ‚Ä¢  ${T[lang].menu}  ‚Ä¢  ${T[lang].close}`, W/2, y + h*0.88);
  }

  function drawPause(){
    if(S.game==="snake") Snake.draw();
    else Bounce.draw();
    const topH=drawTopBar();

    ctx.fillStyle="rgba(0,0,0,.25)";
    const w=W*0.60, h=(H-topH)*0.14;
    rr((W-w)/2, topH + (H-topH)*0.42, w, h, 16, true);

    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font=`${clamp(W*0.055, 16, 28)}px system-ui`;
    ctx.fillText(T[lang].paused, W/2, topH + (H-topH)*0.49);
  }

  // ------------------
  // üêç Snake (fills more of the screen now)
  // ------------------
  const Snake = (() => {
    let GW=0, GH=0; // dynamic grid to fill screen
    let cell=18, ox=0, oy=0;

    let snake=[], dir={x:1,y:0}, food={x:5,y:5};
    let tick=0, speed=7, alive=true;

    function layout(){
      const topH=topBarH();
      const pad = clamp(Math.min(W,H)*0.04, 10, 18);

      const usableW = W - pad*2;
      const usableH = (H - topH) - pad*2;

      // dynamic grid based on aspect
      cell = clamp(Math.floor(Math.min(usableW/26, usableH/18)), 14, 28);
      GW = Math.floor(usableW / cell);
      GH = Math.floor(usableH / cell);
      GW = clamp(GW, 18, 30);
      GH = clamp(GH, 14, 22);

      ox = Math.floor((W - cell*GW)/2);
      oy = Math.floor(topH + ((H-topH) - cell*GH)/2);
    }

    function placeFood(){
      for(let i=0;i<4000;i++){
        const fx=(Math.random()*GW)|0;
        const fy=(Math.random()*GH)|0;
        if(!snake.some(p=>p.x===fx && p.y===fy)){ food={x:fx,y:fy}; return; }
      }
      food={x:1,y:1};
    }

    function init(){
      layout();
      S.apples=0; S.len=3; S.level=1;

      const sy=(GH/2)|0;
      snake=[{x:6,y:sy},{x:5,y:sy},{x:4,y:sy}];
      dir={x:1,y:0};
      tick=0; speed=7; alive=true;
      placeFood();
    }

    function setDir(nx,ny){
      if(nx===-dir.x && ny===-dir.y) return;
      dir={x:nx,y:ny};
    }

    function step(){
      if(!alive) return;

      if(jp.UP) setDir(0,-1);
      else if(jp.DOWN) setDir(0,1);
      else if(jp.LEFT) setDir(-1,0);
      else if(jp.RIGHT) setDir(1,0);

      const h=snake[0];
      const nx=h.x+dir.x, ny=h.y+dir.y;

      if(nx<0||nx>=GW||ny<0||ny>=GH){ gameOver(); return; }
      if(snake.some((p,i)=>i>0 && p.x===nx && p.y===ny)){ gameOver(); return; }

      snake.unshift({x:nx,y:ny});

      if(nx===food.x && ny===food.y){
        S.score += 10;
        S.apples++;
        S.len=snake.length;
        S.level = 1 + Math.floor(S.apples/5);
        speed = 7 + (S.level-1)*1.2;
        placeFood();
        setBest("snake", S.score);
      }else{
        snake.pop();
        S.len=snake.length;
      }
    }

    function gameOver(){
      alive=false;
      showResult("over", [
        `${T[lang].score}: ${S.score}`,
        `${T[lang].apples}: ${S.apples}`,
        `${T[lang].len}: ${S.len}`,
        `${T[lang].time}: ${fmtTime(timeMs())}`
      ]);
    }

    function update(dt){
      layout();
      tick += dt*speed;
      while(tick>=1){
        tick-=1;
        step();
        if(S.mode!=="play") break;
      }
    }

    function draw(){
      layout();
      ctx.fillStyle="#061025";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle="rgba(255,255,255,.04)";
      rr(ox-10, oy-10, cell*GW+20, cell*GH+20, 18, true);

      // grid
      ctx.fillStyle="rgba(255,255,255,.025)";
      for(let y=0;y<=GH;y++) ctx.fillRect(ox, oy+y*cell, cell*GW, 1);
      for(let x=0;x<=GW;x++) ctx.fillRect(ox+x*cell, oy, 1, cell*GH);

      // food
      const fx=ox+food.x*cell+cell/2;
      const fy=oy+food.y*cell+cell/2;
      ctx.fillStyle="rgba(255,211,79,.95)";
      ctx.beginPath(); ctx.arc(fx,fy, cell*0.24, 0, Math.PI*2); ctx.fill();

      // snake
      for(let i=snake.length-1;i>=0;i--){
        const p=snake[i];
        const x=ox+p.x*cell, y=oy+p.y*cell;
        const inset=Math.max(2, Math.floor(cell*0.12));
        const r=Math.floor(cell*0.28);

        if(i===0){
          ctx.fillStyle="rgba(78,161,255,.95)";
          rr(x+inset,y+inset,cell-inset*2,cell-inset*2,r,true);

          const ex1=x+cell*0.38, ex2=x+cell*0.62;
          const ey=y+cell*0.43;
          ctx.fillStyle="rgba(255,255,255,.92)";
          ctx.beginPath(); ctx.arc(ex1,ey, Math.max(2,cell*0.07), 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(ex2,ey, Math.max(2,cell*0.07), 0, Math.PI*2); ctx.fill();
          ctx.fillStyle="rgba(0,0,0,.65)";
          ctx.beginPath(); ctx.arc(ex1,ey, Math.max(1.3,cell*0.035), 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(ex2,ey, Math.max(1.3,cell*0.035), 0, Math.PI*2); ctx.fill();
        }else{
          ctx.fillStyle="rgba(78,161,255,.72)";
          rr(x+inset,y+inset,cell-inset*2,cell-inset*2,r,true);
        }
      }
    }

    return { init, update, draw };
  })();
// ------------------
  // üî¥ Bounce
  // ------------------
  const Bounce = (() => {
    const TILE=26;

    const LEVELS=[
      [
        "........................................",
        ".............o..........................",
        "............#####......................G",
        "........................................",
        "....o......................o............",
        "....###...........C......#####..........",
        "..................^.....................",
        "############......^......#############..",
        "........................................",
        "..............o.........................",
        ".............#####......................",
        "........................................",
        "############.............#############..",
        "........................................",
        "###############################.........",
      ]
    ];

    let map=[], Wm=0,Hm=0, stage=0;
    let respawn={x:TILE*2,y:TILE*2};
    const ball={x:0,y:0,vx:0,vy:0,r:11};
    let camX=0, camY=0;

    function tileAt(tx,ty){
      if(ty<0||ty>=Hm||tx<0||tx>=Wm) return ".";
      return map[ty][tx];
    }
    function setTile(tx,ty,v){
      if(ty<0||ty>=Hm||tx<0||tx>=Wm) return;
      map[ty][tx]=v;
    }
    function isSolid(tx,ty){ return tileAt(tx,ty)==="#"; }

    function loadStage(i, fresh){
      stage=i;
      S.stage=i+1;

      map=LEVELS[i].map(r=>r.split(""));
      Hm=map.length; Wm=map[0].length;

      let hoops=0;
      for(let y=0;y<Hm;y++)for(let x=0;x<Wm;x++) if(map[y][x]==="o") hoops++;
      S.hoopsLeft=hoops;

      respawn={x:TILE*2,y:TILE*2};
      ball.x=respawn.x; ball.y=respawn.y; ball.vx=0; ball.vy=0;

      if(fresh){ S.lives=3; S.deaths=0; }

      camX=0; camY=0;
    }

    function init(){ loadStage(0,true); }

    function circleRect(cx,cy,cr, rx,ry,rw,rh){
      const nx=clamp(cx,rx,rx+rw);
      const ny=clamp(cy,ry,ry+rh);
      const dx=cx-nx, dy=cy-ny;
      return (dx*dx+dy*dy) <= cr*cr;
    }

    function collideSolids(cx,cy,cr){
      const L=((cx-cr)/TILE)|0, R=((cx+cr)/TILE)|0;
      const Tt=((cy-cr)/TILE)|0, B=((cy+cr)/TILE)|0;
      for(let ty=Tt;ty<=B;ty++){
        for(let tx=L;tx<=R;tx++){
          if(isSolid(tx,ty)){
            const rx=tx*TILE, ry=ty*TILE;
            if(circleRect(cx,cy,cr, rx,ry,TILE,TILE)) return true;
          }
        }
      }
      return false;
    }

    function loseLife(){
      S.lives--; S.deaths++;
      if(S.lives<=0){
        showResult("over", [
          `${T[lang].level}: ${S.stage}`,
          `${T[lang].score}: ${S.score}`,
          `Deaths: ${S.deaths}`,
          `${T[lang].time}: ${fmtTime(timeMs())}`
        ]);
        return;
      }
      ball.x=respawn.x; ball.y=respawn.y; ball.vx=0; ball.vy=0;
    }

    function interact(){
      const tx=(ball.x/TILE)|0, ty=(ball.y/TILE)|0;

      for(let y=ty-1;y<=ty+1;y++){
        for(let x=tx-1;x<=tx+1;x++){
          const t=tileAt(x,y);
          const rx=x*TILE, ry=y*TILE;

          if(t==="o" && circleRect(ball.x,ball.y,ball.r, rx+6,ry+6,TILE-12,TILE-12)){
            setTile(x,y,".");
            S.score += 50;
            S.hoopsLeft = Math.max(0,S.hoopsLeft-1);
            setBest("bounce", S.score);
          }

          if(t==="^" && circleRect(ball.x,ball.y,ball.r, rx,ry,TILE,TILE)){
            loseLife(); return;
          }

          if(t==="C" && circleRect(ball.x,ball.y,ball.r, rx,ry,TILE,TILE)){
            respawn={x:rx+TILE/2, y:ry+TILE/2};
            setTile(x,y,".");
          }

          if(t==="G" && circleRect(ball.x,ball.y,ball.r, rx,ry,TILE,TILE)){
            if(S.hoopsLeft<=0){
              showResult("win", [
                `${T[lang].score}: ${S.score}`,
                `Deaths: ${S.deaths}`,
                `${T[lang].time}: ${fmtTime(timeMs())}`
              ]);
            }else{
              toast(T[lang].locked);
            }
          }
        }
      }
    }

    function update(dt){
      const accel=1200, maxVx=520, gravity=1650, drag=0.995;

      if(hold.left) ball.vx -= accel*dt;
      if(hold.right) ball.vx += accel*dt;
      ball.vx = clamp(ball.vx, -maxVx, maxVx);
      ball.vy += gravity*dt;

      // axis separation
      ball.x += ball.vx*dt;
      if(collideSolids(ball.x,ball.y,ball.r)){
        ball.x -= ball.vx*dt;
        ball.vx = -ball.vx*0.65;
      }

      ball.y += ball.vy*dt;
      if(collideSolids(ball.x,ball.y,ball.r)){
        ball.y -= ball.vy*dt;
        ball.vy = -Math.abs(ball.vy)*0.72;
        ball.vx *= 0.985;
      }

      ball.vx *= Math.pow(drag, dt*60);
      ball.vy *= Math.pow(drag, dt*60);

      if(ball.y > Hm*TILE + 420){ loseLife(); return; }
      interact();

      // camera
      const mapW=Wm*TILE, mapH=Hm*TILE;
      camX = clamp(ball.x - W*0.50, 0, Math.max(0, mapW-W));
      camY = clamp(ball.y - H*0.55, 0, Math.max(0, mapH-H));
    }

    function draw(){
      ctx.fillStyle="#4aaed6";
      ctx.fillRect(0,0,W,H);

      const startTx=(camX/TILE)|0, endTx=((camX+W)/TILE+1)|0;
      const startTy=(camY/TILE)|0, endTy=((camY+H)/TILE+1)|0;

      for(let ty=startTy;ty<endTy;ty++){
        for(let tx=startTx;tx<endTx;tx++){
          const t=tileAt(tx,ty);
          const x=tx*TILE - camX;
          const y=ty*TILE - camY;

          if(t==="#"){
            ctx.fillStyle="#b55a2d";
            ctx.fillRect(x,y,TILE,TILE);
            ctx.strokeStyle="#8f3d1f";
            ctx.lineWidth=2;
            ctx.strokeRect(x+1,y+1,TILE-2,TILE-2);
          }else if(t==="o"){
            ctx.strokeStyle="rgba(255,211,79,.95)";
            ctx.lineWidth=4;
            ctx.beginPath();
            ctx.arc(x+TILE/2,y+TILE/2,TILE*0.28,0,Math.PI*2);
            ctx.stroke();
          }else if(t==="^"){
            ctx.fillStyle="rgba(10,16,28,.92)";
            ctx.beginPath();
            ctx.moveTo(x, y+TILE);
            ctx.lineTo(x+TILE*0.25, y+TILE*0.35);
            ctx.lineTo(x+TILE*0.5, y+TILE);
            ctx.lineTo(x+TILE*0.75, y+TILE*0.35);
            ctx.lineTo(x+TILE, y+TILE);
            ctx.closePath();
            ctx.fill();
          }else if(t==="G"){
            ctx.fillStyle=(S.hoopsLeft<=0) ? "rgba(255,255,255,.22)" : "rgba(0,0,0,.20)";
            rr(x+2,y+2,TILE-4,TILE-4,7,true);
          }else if(t==="C"){
            ctx.fillStyle="rgba(255,255,255,.18)";
            rr(x+4,y+4,TILE-8,TILE-8,7,true);
          }
        }
      }

      // ball
      const bx=ball.x-camX, by=ball.y-camY;
      ctx.fillStyle="#e83535";
      ctx.beginPath(); ctx.arc(bx,by,ball.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,.30)";
      ctx.beginPath(); ctx.arc(bx-ball.r*0.35,by-ball.r*0.35,ball.r*0.35,0,Math.PI*2); ctx.fill();

      // toast
      if(S.toastText && now()<S.toastUntil){
        ctx.fillStyle="rgba(0,0,0,.25)";
        const w=W*0.74, h=H*0.10;
        rr((W-w)/2, H*0.78, w, h, 16, true);
        ctx.fillStyle="rgba(255,255,255,.92)";
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.font=`${clamp(W*0.045, 14, 22)}px system-ui`;
        ctx.fillText(S.toastText, W/2, H*0.83);
      }
    }

    return { init, update, draw };
  })();

  // ------------------
  // Main loop
  // ------------------
  let last=now();
  function loop(){
    resize();
    const t=now();
    const dt=clamp((t-last)/1000, 0, 0.033);
    last=t;

    // global actions
    if(jp.SELECT) toggleLang();
    if(jp.START && (S.mode==="play" || S.mode==="pause")) togglePause();
    if(jp.L && S.mode!=="menu") startGame(S.game);
    if(jp.R) goMenu();

    // menu
    if(S.mode==="menu"){
      if(jp.LEFT || jp.UP){ S.menuIdx=0; S.game="snake"; }
      if(jp.RIGHT || jp.DOWN){ S.menuIdx=1; S.game="bounce"; }
      if(jp.A) startGame(S.menuIdx===0 ? "snake" : "bounce");
      drawMenu();
      clearJP();
      requestAnimationFrame(loop);
      return;
    }

    // result
    if(S.mode==="result"){
      if(jp.A) startGame(S.game);
      if(jp.B) goMenu();
      drawResult();
      clearJP();
      requestAnimationFrame(loop);
      return;
    }

    // pause
    if(S.mode==="pause"){
      drawPause();
      clearJP();
      requestAnimationFrame(loop);
      return;
    }

    // play
    if(S.mode==="play"){
      if(S.game==="snake"){
        Snake.update(dt);
        Snake.draw();
      }else{
        Bounce.update(dt);
        Bounce.draw();
      }
      drawTopBar();
    }

    clearJP();
    requestAnimationFrame(loop);
  }

  // boot
  goMenu();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
