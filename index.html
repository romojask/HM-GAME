<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#0b1220" />
  <title>HM GAME</title>
</head>

<body>
  <header class="topbar">
    <div class="brand">
      <div class="logo">HM</div>
      <div class="brandText">
        <div class="title">HM GAME ğŸ®</div>
        <div class="subtitle" id="subtitle">Choose a game</div>
      </div>
    </div>

    <div class="topActions">
      <button class="btn" id="btnLang" title="Language">AR</button>
      <button class="btn" id="btnMenu" title="Menu">Menu</button>
      <button class="btn" id="btnPause" title="Pause/Resume">Pause</button>
      <button class="btn btnPrimary" id="btnRestart" title="Restart">Restart</button>
    </div>
  </header>

  <main class="main">
    <!-- GAME AREA (TOP) -->
    <section class="gamePanel">
      <div class="gameFrame">
        <canvas id="game" width="360" height="540"></canvas>

        <!-- HUD -->
        <div class="hud">
          <div class="hudLeft">
            <span class="pill" id="hudGame">HM GAME</span>
            <span class="pill" id="hudMode">â€”</span>
          </div>
          <div class="hudRight">
            <span class="pill" id="hudStat1">Score: 0</span>
            <span class="pill" id="hudStat2">Best: 0</span>
            <span class="pill" id="hudTime">00:00</span>
          </div>
        </div>

        <!-- Overlay (Win/Lose/Pause/Menu) -->
        <div class="overlay" id="overlay">
          <div class="card">
            <div class="cardTitle" id="ovTitle">HM GAME</div>
            <div class="cardText" id="ovText">Choose a game below.</div>
            <div class="cardActions" id="ovActions"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- CONTROLS AREA (BOTTOM) -->
    <section class="controlsPanel">
      <div class="picker" id="picker">
        <button class="pick isActive" data-game="menu">ğŸ  HM GAME</button>
        <button class="pick" data-game="snake">ğŸ Snake</button>
        <button class="pick" data-game="bounce">ğŸ”´ Bounce</button>
      </div>

      <!-- MENU help -->
      <div class="controls" id="controlsMenu">
        <div class="helpBox">
          <div class="helpTitle">HM GAME âœ¨</div>
          <div class="helpText" id="helpText">
            Pick a game above, then use the controls below.<br/>
            Keyboard is supported too.
          </div>
        </div>
      </div>

      <!-- SNAKE controls -->
      <div class="controls" id="controlsSnake" hidden>
        <div class="dpad">
          <button class="pad" data-act="up">â–²</button>
          <div class="mid">
            <button class="pad" data-act="left">â—€</button>
            <button class="pad padCenter" data-act="noop">HM</button>
            <button class="pad" data-act="right">â–¶</button>
          </div>
          <button class="pad" data-act="down">â–¼</button>
        </div>

        <div class="side">
          <button class="big" data-act="pause">â¸ï¸ Pause</button>
          <button class="big danger" data-act="exit">ğŸšª Exit</button>
        </div>
      </div>

      <!-- BOUNCE controls (accurate: LEFT/RIGHT only) -->
      <div class="controls" id="controlsBounce" hidden>
        <div class="bounceRow">
          <button class="big" data-act="bLeftHold">â—€ Left</button>
          <button class="big padCenter" data-act="pause">â¸ï¸ Pause</button>
          <button class="big" data-act="bRightHold">Right â–¶</button>
        </div>

        <div class="side">
          <button class="big" data-act="restart">ğŸ” Restart</button>
          <button class="big danger" data-act="exit">ğŸšª Exit</button>
        </div>
      </div>

      <div class="footer">Â© HM GAME</div>
    </section>
  </main>
<style>
    :root{
      --bg:#0b1220;
      --panel:#111a2a;
      --panel2:#0f1726;
      --text:#eaf1ff;
      --muted:#a7b7de;
      --line:rgba(255,255,255,.10);
      --accent:#4ea1ff;
      --danger:#ff4e6a;

      /* Nokia Snake LCD */
      --lcd:#9acb3c;
      --lcd2:#86bb2f;
      --pixel:#0a1b0a;
      --frame:#2b3550;

      /* Bounce */
      --sky:#6fd4ff;
      --brick:#b55a2d;
      --brick2:#8f3d1f;
      --ring:#ffd34f;
      --ball:#e83535;
      --spike:#1b2338;
      --gate:#ffffff;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 800px at 80% 20%, #15244b, var(--bg));
      color:var(--text);
      overscroll-behavior:none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .topbar{
      position: sticky;
      top:0;
      z-index:50;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 12px;
      background: color-mix(in oklab, var(--panel) 92%, black);
      border-bottom:1px solid var(--line);
      backdrop-filter: blur(10px);
    }

    .brand{display:flex; align-items:center; gap:10px;}
    .logo{
      width:42px; height:42px;
      border-radius:12px;
      display:grid; place-items:center;
      font-weight:1000;
      background: rgba(78,161,255,.18);
      border: 1px solid rgba(78,161,255,.55);
    }
    .title{ font-weight:1000; font-size:16px; }
    .subtitle{ color:var(--muted); font-size:12px; margin-top:2px; }

    .topActions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .btn{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:900;
      cursor:pointer;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btnPrimary{
      background: rgba(78,161,255,.18);
      border-color: rgba(78,161,255,.55);
    }

    .main{
      height: calc(100vh - 70px);
      display:grid;
      grid-template-rows: 1fr auto;
      gap:10px;
      padding: 10px 10px 14px;
    }

    .gamePanel{
      background: color-mix(in oklab, var(--panel2) 88%, black);
      border:1px solid var(--line);
      border-radius: 16px;
      overflow:hidden;
      min-height: 260px;
    }

    .gameFrame{ position:relative; width:100%; height:100%; }
    canvas#game{ width:100%; height:100%; display:block; background:#061025; }

    .hud{
      position:absolute;
      top:10px; left:10px; right:10px;
      display:flex; justify-content:space-between; gap:10px;
      pointer-events:none;
    }
    .hudLeft,.hudRight{ display:flex; gap:8px; flex-wrap:wrap; }

    .pill{
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.16);
      color:var(--text);
      font-size:12px;
      font-weight:900;
      backdrop-filter: blur(8px);
    }

    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:16px;
      background: rgba(0,0,0,.38);
    }
    .overlay[hidden]{ display:none; }
    .card{
      width:min(540px, 100%);
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,26,42,.92);
      padding: 14px;
      box-shadow: 0 22px 70px rgba(0,0,0,.45);
    }
    .cardTitle{ font-size:18px; font-weight:1000; margin-bottom:6px; }
    .cardText{ color:var(--muted); font-size:13px; line-height:1.7; }
    .cardActions{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }

    .controlsPanel{
      background: color-mix(in oklab, var(--panel) 92%, black);
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
    }

    .picker{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .pick{
      flex:1 1 130px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:1000;
      cursor:pointer;
      user-select:none;
      text-align:center;
    }
    .pick:active{ transform: translateY(1px); }
    .pick.isActive{
      border-color: rgba(78,161,255,.60);
      background: rgba(78,161,255,.14);
    }

    .controls{ display:flex; gap:12px; flex-wrap:wrap; justify-content:space-between; align-items:stretch; }
    .helpBox{
      width:100%;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px dashed rgba(255,255,255,.18);
      background: rgba(255,255,255,.03);
    }
    .helpTitle{ font-weight:1000; margin-bottom:4px; }
    .helpText{ color:var(--muted); font-size:13px; line-height:1.6; }

    .dpad{
      flex:1 1 220px;
      display:grid;
      gap:8px;
      justify-items:center;
      padding: 8px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .mid{ display:flex; gap:8px; }
    .pad, .big{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 16px;
      font-weight:1000;
      cursor:pointer;
      user-select:none;
    }
    .pad{ width: 64px; height: 56px; font-size: 20px; }
    .padCenter{
      border-color: rgba(78,161,255,.55);
      background: rgba(78,161,255,.14);
    }
    .side{
      flex:1 1 170px;
      display:grid;
      gap:10px;
    }
    .big{ width:100%; min-height:56px; padding:10px 12px; font-size:16px; }
    .danger{
      border-color: rgba(255,78,106,.55);
      background: rgba(255,78,106,.12);
    }

    .bounceRow{
      flex:1 1 300px;
      display:flex;
      gap:10px;
    }
    .bounceRow .big{ flex:1 1 0; }

    .footer{
      margin-top: 10px;
      text-align:center;
      font-size: 12px;
      color: rgba(255,255,255,.55);
    }

    @media (max-width: 420px){
      .btn{ padding:9px 10px; }
      .pad{ width: 60px; height: 54px; }
      .big{ min-height:54px; }
    }
  </style>
<script>
  (() => {
    "use strict";

    // ===== Elements =====
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha:false });

    const subtitle = document.getElementById("subtitle");
    const hudMode = document.getElementById("hudMode");
    const hudStat1 = document.getElementById("hudStat1");
    const hudStat2 = document.getElementById("hudStat2");
    const hudTime  = document.getElementById("hudTime");

    const overlay = document.getElementById("overlay");
    const ovTitle = document.getElementById("ovTitle");
    const ovText  = document.getElementById("ovText");
    const ovActions = document.getElementById("ovActions");

    const btnLang = document.getElementById("btnLang");
    const btnMenu = document.getElementById("btnMenu");
    const btnPause = document.getElementById("btnPause");
    const btnRestart = document.getElementById("btnRestart");

    const picks = [...document.querySelectorAll(".pick")];
    const controlsMenu = document.getElementById("controlsMenu");
    const controlsSnake = document.getElementById("controlsSnake");
    const controlsBounce = document.getElementById("controlsBounce");
    const helpText = document.getElementById("helpText");

    // ===== Utils =====
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const now = ()=>performance.now();
    const pad2 = (n)=>String(n).padStart(2,"0");

    function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

    // ===== Language (AR/EN) =====
    const LANG_KEY = "HM_GAME_LANG";
    let lang = (localStorage.getItem(LANG_KEY) || "en"); // en | ar

    const T = {
      en: {
        choose:"Choose a game",
        menuHelp:"Pick a game above, then use the controls below.<br/>Keyboard is supported too.",
        menu:"Menu",
        pause:"Pause",
        resume:"Resume",
        restart:"Restart",
        exit:"Exit",
        snake:"Snake",
        bounce:"Bounce",
        pausedTitle:"â¸ï¸ HM GAME â€” Paused",
        pausedText:"Game is paused.<br/>Press Resume to continue.",
        resumeBtn:"Resume",
        winTitle:"ğŸ† YOU WIN!",
        loseTitle:"ğŸ˜µ Game Over",
        backMenu:"Back to Menu",
        playSnake:"Play Snake",
        playBounce:"Play Bounce",
        best:"Best",
      },
      ar: {
        choose:"Ø§Ø®ØªØ± Ù„Ø¹Ø¨Ø©",
        menuHelp:"Ø§Ø®ØªØ± Ù„Ø¹Ø¨Ø© Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰ØŒ Ø«Ù… Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¨Ø§Ù„Ø£Ø³ÙÙ„.<br/>ÙŠØ¯Ø¹Ù… Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø£ÙŠØ¶Ù‹Ø§.",
        menu:"Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©",
        pause:"Ø¥ÙŠÙ‚Ø§Ù",
        resume:"Ù…ØªØ§Ø¨Ø¹Ø©",
        restart:"Ø¥Ø¹Ø§Ø¯Ø©",
        exit:"Ø®Ø±ÙˆØ¬",
        snake:"Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†",
        bounce:"Ø¨Ø§ÙˆÙ†Ø³",
        pausedTitle:"â¸ï¸ HM GAME â€” Ù…ØªÙˆÙ‚Ù",
        pausedText:"Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØªÙˆÙ‚ÙØ© Ù…Ø¤Ù‚ØªÙ‹Ø§.<br/>Ø§Ø¶ØºØ· Ù…ØªØ§Ø¨Ø¹Ø© Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù„Ø¹Ø¨.",
        resumeBtn:"Ù…ØªØ§Ø¨Ø¹Ø©",
        winTitle:"ğŸ† Ù„Ù‚Ø¯ Ø±Ø¨Ø­Øª!",
        loseTitle:"ğŸ˜µ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©",
        backMenu:"Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©",
        playSnake:"Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†",
        playBounce:"Ø§Ø¨Ø¯Ø£ Ø¨Ø§ÙˆÙ†Ø³",
        best:"Ø£ÙØ¶Ù„",
      }
    };

    function applyLang(){
      document.documentElement.lang = lang;
      document.documentElement.dir = (lang === "ar") ? "rtl" : "ltr";

      btnLang.textContent = (lang === "ar") ? "EN" : "AR";
      btnMenu.textContent = T[lang].menu;
      btnPause.textContent = state.paused ? T[lang].resume : T[lang].pause;
      btnRestart.textContent = T[lang].restart;

      helpText.innerHTML = T[lang].menuHelp;
      subtitle.textContent = T[lang].choose;

      // picker labels
      for (const b of picks){
        const g = b.dataset.game;
        if (g==="menu") b.textContent = "ğŸ  HM GAME";
        if (g==="snake") b.textContent = `ğŸ ${T[lang].snake}`;
        if (g==="bounce") b.textContent = `ğŸ”´ ${T[lang].bounce}`;
      }
    }

    btnLang.addEventListener("click", () => {
      lang = (lang === "en") ? "ar" : "en";
      localStorage.setItem(LANG_KEY, lang);
      applyLang();
      // update overlay text if shown
      if (!overlay.hidden) refreshOverlayForState();
    });

    // ===== Overlay =====
    function showOverlay(title, html, actions){
      ovTitle.textContent = title;
      ovText.innerHTML = html;
      ovActions.innerHTML = "";
      for (const a of actions){
        const b = document.createElement("button");
        b.className = "btn " + (a.primary ? "btnPrimary" : "");
        if (a.danger) b.className += " danger";
        b.textContent = a.label;
        b.addEventListener("click", a.onClick);
        ovActions.appendChild(b);
      }
      overlay.hidden = false;
    }
    function hideOverlay(){ overlay.hidden = true; }

    // ===== Canvas Resize (mobile friendly) =====
    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
    }
    window.addEventListener("resize", resizeCanvas);

    // ===== Input =====
    const input = {
      snakeQueued:null,
      bounceLeft:false,
      bounceRight:false,
      pauseToggle:false,
      restart:false,
      exit:false
    };

    function bindTouch(el, down, up){
      el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); down?.(); });
      el.addEventListener("pointerup", (e)=>{ e.preventDefault(); up?.(); });
      el.addEventListener("pointercancel", (e)=>{ e.preventDefault(); up?.(); });
      el.addEventListener("pointerleave", (e)=>{ e.preventDefault(); up?.(); });
    }

    function queueSnakeDir(x,y){ input.snakeQueued = {x,y}; }

    // Buttons (bottom)
    document.querySelectorAll("[data-act]").forEach(btn=>{
      const a = btn.dataset.act;

      if (a==="up") bindTouch(btn, ()=>queueSnakeDir(0,-1));
      if (a==="down") bindTouch(btn, ()=>queueSnakeDir(0, 1));
      if (a==="left") bindTouch(btn, ()=>queueSnakeDir(-1,0));
      if (a==="right") bindTouch(btn, ()=>queueSnakeDir(1,0));

      if (a==="pause") bindTouch(btn, ()=>input.pauseToggle = true);
      if (a==="restart") bindTouch(btn, ()=>input.restart = true);
      if (a==="exit") bindTouch(btn, ()=>input.exit = true);

      if (a==="bLeftHold") bindTouch(btn, ()=>input.bounceLeft=true, ()=>input.bounceLeft=false);
      if (a==="bRightHold") bindTouch(btn, ()=>input.bounceRight=true, ()=>input.bounceRight=false);
    });

    // Keyboard
    window.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();

      if (state.game==="snake"){
        if (k==="arrowup" || k==="w") queueSnakeDir(0,-1);
        if (k==="arrowdown" || k==="s") queueSnakeDir(0, 1);
        if (k==="arrowleft" || k==="a") queueSnakeDir(-1,0);
        if (k==="arrowright" || k==="d") queueSnakeDir(1,0);
        if (k==="p") input.pauseToggle = true;
        if (k==="r") input.restart = true;
        if (k==="escape") input.exit = true;
      }

      if (state.game==="bounce"){
        if (k==="arrowleft" || k==="a") input.bounceLeft = true;
        if (k==="arrowright" || k==="d") input.bounceRight = true;
        if (k==="p") input.pauseToggle = true;
        if (k==="r") input.restart = true;
        if (k==="escape") input.exit = true;
      }

      if (state.game==="menu"){
        if (k==="1") startGame("snake");
        if (k==="2") startGame("bounce");
      }
    }, {passive:false});

    window.addEventListener("keyup", (e)=>{
      const k = e.key.toLowerCase();
      if (state.game==="bounce"){
        if (k==="arrowleft" || k==="a") input.bounceLeft = false;
        if (k==="arrowright" || k==="d") input.bounceRight = false;
      }
    });

    // Picker
    function setActivePick(game){
      picks.forEach(b=>b.classList.toggle("isActive", b.dataset.game===game));
    }
    picks.forEach(b=>{
      b.addEventListener("click", ()=>{
        const g = b.dataset.game;
        if (g==="menu") goMenu();
        else startGame(g);
      });
    });

    // Top buttons
    btnMenu.addEventListener("click", ()=>goMenu());
    btnPause.addEventListener("click", ()=>input.pauseToggle = true);
    btnRestart.addEventListener("click", ()=>input.restart = true);

    // ===== Storage (Best) =====
    const BEST_KEY = "HM_GAME_BESTS";
    const bests = (()=>{ try{return JSON.parse(localStorage.getItem(BEST_KEY)||"{}");}catch{return{};} })();
    function getBest(k){ return bests[k] ?? 0; }
    function setBest(k, v){
      if ((bests[k] ?? 0) < v){ bests[k]=v; localStorage.setItem(BEST_KEY, JSON.stringify(bests)); }
      state.best = getBest(k);
    }

    // ===== State =====
    const state = {
      game:"menu", // menu|snake|bounce
      paused:false,
      score:0,
      best:0,
      startedAt: 0,
      // additional stats
      statA:0,
      statB:0,
      level:1
    };

    function setControls(game){
      controlsMenu.hidden = game!=="menu";
      controlsSnake.hidden = game!=="snake";
      controlsBounce.hidden = game!=="bounce";
    }

    function formatTime(ms){
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const r = s%60;
      return `${pad2(m)}:${pad2(r)}`;
    }

    function updateHUD(){
      const elapsed = state.startedAt ? (now() - state.startedAt) : 0;
      hudTime.textContent = formatTime(elapsed);

      if (state.game==="menu"){
        hudMode.textContent = "â€”";
        hudStat1.textContent = "HM GAME";
        hudStat2.textContent = "";
        return;
      }

      btnPause.textContent = state.paused ? T[lang].resume : T[lang].pause;

      if (state.game==="snake"){
        hudMode.textContent = `ğŸ ${T[lang].snake} â€¢ Lv ${state.level}`;
        hudStat1.textContent = `Score: ${state.score}`;
        hudStat2.textContent = `${T[lang].best}: ${state.best}`;
      }

      if (state.game==="bounce"){
        hudMode.textContent = `ğŸ”´ ${T[lang].bounce} â€¢ Lv ${state.level}`;
        hudStat1.textContent = `Score: ${state.score}`;
        hudStat2.textContent = `${T[lang].best}: ${state.best}`;
      }
    }

    function refreshOverlayForState(){
      if (state.game==="menu"){
        showMenuOverlay();
      } else if (state.paused){
        showPauseOverlay();
      }
    }

    function showMenuOverlay(){
      showOverlay(
        "HM GAME ğŸ®",
        (lang==="en")
          ? `Choose a game below:<br/>ğŸ Snake (Nokia LCD) â€¢ ğŸ”´ Bounce (classic style)<br/><br/>Controls are optimized for phones âœ…`
          : `Ø§Ø®ØªØ± Ù„Ø¹Ø¨Ø© Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„:<br/>ğŸ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù† (Ø´Ø§Ø´Ø© Ù†ÙˆÙƒÙŠØ§) â€¢ ğŸ”´ Ø¨Ø§ÙˆÙ†Ø³ (Ù‚Ø±ÙŠØ¨ Ù…Ù† Ø§Ù„Ø£ØµÙ„)<br/><br/>Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¬ÙˆØ§Ù„ âœ…`,
        [
          { label: `ğŸ ${T[lang].playSnake}`, primary:true, onClick: ()=>startGame("snake") },
          { label: `ğŸ”´ ${T[lang].playBounce}`, primary:false, onClick: ()=>startGame("bounce") },
        ]
      );
    }

    function showPauseOverlay(){
      showOverlay(
        T[lang].pausedTitle,
        T[lang].pausedText,
        [
          { label: T[lang].resumeBtn, primary:true, onClick: ()=>{ state.paused=false; hideOverlay(); } },
          { label: T[lang].restart, onClick: ()=>{ input.restart=true; hideOverlay(); } },
          { label: T[lang].backMenu, danger:true, onClick: ()=>goMenu() },
        ]
      );
    }

    function togglePause(){
      if (state.game==="menu") return;
      state.paused = !state.paused;
      if (state.paused) showPauseOverlay();
      else hideOverlay();
    }

    // ===== Games placeholders (defined in next parts) =====
    const Snake = {};
    const Bounce = {};

    function goMenu(){
      state.game="menu";
      state.paused=false;
      state.score=0;
      state.best=0;
      state.startedAt=0;
      state.level=1;
      setControls("menu");
      setActivePick("menu");
      subtitle.textContent = T[lang].choose;
      showMenuOverlay();
      drawMenu();
    }

    function startGame(game){
      hideOverlay();
      state.game=game;
      state.paused=false;
      state.score=0;
      state.statA=0;
      state.statB=0;
      state.level=1;
      state.startedAt = now();

      setControls(game);
      setActivePick(game);

      if (game==="snake"){
        subtitle.textContent = (lang==="en") ? "Playing Snake" : "ØªÙ„Ø¹Ø¨ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†";
        state.best = getBest("snake");
        Snake.init();
      }
      if (game==="bounce"){
        subtitle.textContent = (lang==="en") ? "Playing Bounce" : "ØªÙ„Ø¹Ø¨ Ø¨Ø§ÙˆÙ†Ø³";
        state.best = getBest("bounce");
        Bounce.init();
      }
    }

    // ===== Draw Menu background =====
    function drawMenu(){
      resizeCanvas();
      ctx.fillStyle = "#061025";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.textAlign = "center";
      ctx.font = `${Math.floor(canvas.width*0.07)}px system-ui`;
      ctx.fillText("HM GAME ğŸ®", canvas.width/2, canvas.height*0.35);

      ctx.fillStyle = "rgba(255,255,255,.70)";
      ctx.font = `${Math.floor(canvas.width*0.04)}px system-ui`;
      ctx.fillText(lang==="en" ? "Choose a game below" : "Ø§Ø®ØªØ± Ù„Ø¹Ø¨Ø© Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„", canvas.width/2, canvas.height*0.45);

      ctx.fillStyle = "rgba(78,161,255,.40)";
      ctx.font = `${Math.floor(canvas.width*0.032)}px system-ui`;
      ctx.fillText(lang==="en" ? "Mobile controls ready âœ…" : "Ø£Ø²Ø±Ø§Ø± Ø¬ÙˆØ§Ù„ Ø¬Ø§Ù‡Ø²Ø© âœ…", canvas.width/2, canvas.height*0.53);
    }

    // ===== Main Loop =====
    let last = now();
    function loop(){
      resizeCanvas();
      const t = now();
      const dt = clamp((t-last)/1000, 0, 0.04);
      last = t;

      if (input.pauseToggle){ input.pauseToggle=false; togglePause(); }
      if (input.exit){ input.exit=false; goMenu(); }

      if (state.game==="menu"){
        drawMenu();
      } else if (state.game==="snake"){
        if (input.restart){ input.restart=false; Snake.init(); state.paused=false; hideOverlay(); state.startedAt=now(); }
        if (!state.paused) Snake.update(dt);
        Snake.draw();
      } else if (state.game==="bounce"){
        if (input.restart){ input.restart=false; Bounce.init(); state.paused=false; hideOverlay(); state.startedAt=now(); }
        if (!state.paused) Bounce.update(dt);
        Bounce.draw();
      }

      updateHUD();
      requestAnimationFrame(loop);
    }

    // Start
    applyLang();
    goMenu();
    requestAnimationFrame(loop);

    // NOTE: Snake + Bounce will be defined in Parts 4 & 5
// =========================
    // ğŸ SNAKE (Nokia LCD style)
    // =========================
    (function defineSnake(){
      // Grid close to classic Nokia feel
      const GW = 28;
      const GH = 18;

      let cell=12, ox=0, oy=0, tick=0, speed=7;
      let snake=[], dir={x:1,y:0}, queued=null, food={x:10,y:9};
      let alive=true;

      // Stats:
      // state.score: points (10 per food)
      // state.statA: apples eaten
      // state.statB: length
      // state.level: speed level

      function layout(){
        const w=canvas.width, h=canvas.height;
        const pad=Math.floor(Math.min(w,h)*0.06);
        const uw=w-pad*2, uh=h-pad*2;
        cell=Math.max(8, Math.floor(Math.min(uw/GW, uh/GH)));
        ox=Math.floor((w - cell*GW)/2);
        oy=Math.floor((h - cell*GH)/2);
      }

      function init(){
        layout();
        snake=[
          {x:6,y:Math.floor(GH/2)},
          {x:5,y:Math.floor(GH/2)},
          {x:4,y:Math.floor(GH/2)},
        ];
        dir={x:1,y:0};
        queued=null;
        tick=0;
        speed=7;
        alive=true;

        state.score=0;
        state.statA=0;
        state.statB=snake.length;
        state.level=1;
        setBest("snake", 0);

        placeFood();
      }

      function placeFood(){
        for (let i=0;i<2000;i++){
          const fx=Math.floor(Math.random()*GW);
          const fy=Math.floor(Math.random()*GH);
          if (!snake.some(p=>p.x===fx && p.y===fy)){
            food={x:fx,y:fy};
            return;
          }
        }
        food={x:1,y:1};
      }

      function step(){
        if (!alive) return;

        if (input.snakeQueued) queued=input.snakeQueued;
        input.snakeQueued=null;

        if (queued){
          const back = (queued.x===-dir.x && queued.y===-dir.y);
          if (!back) dir=queued;
          queued=null;
        }

        const head=snake[0];
        const nx=head.x+dir.x;
        const ny=head.y+dir.y;

        // Classic: hit wall = lose
        if (nx<0 || nx>=GW || ny<0 || ny>=GH){ lose(); return; }

        // Hit self
        if (snake.some((p,i)=>i>0 && p.x===nx && p.y===ny)){ lose(); return; }

        snake.unshift({x:nx,y:ny});

        if (nx===food.x && ny===food.y){
          state.score += 10;
          state.statA += 1;
          state.statB = snake.length;

          // Speed up like old phones (level per 5 apples)
          state.level = 1 + Math.floor(state.statA / 5);
          speed = 7 + (state.level-1) * 1.2;

          setBest("snake", state.score);
          placeFood();

          // Win condition (optional): fill big part of board
          if (snake.length >= Math.floor(GW*GH*0.65)) win();
        } else {
          snake.pop();
          state.statB = snake.length;
        }
      }

      function lose(){
        alive=false;
        setBest("snake", state.score);

        const elapsed = formatTime(now()-state.startedAt);
        const msg = (lang==="en")
          ? `ğŸ˜µ <b>${T[lang].loseTitle}</b><br/>
             Score: <b>${state.score}</b><br/>
             Apples: <b>${state.statA}</b> â€¢ Length: <b>${state.statB}</b><br/>
             Level reached: <b>${state.level}</b><br/>
             Time: <b>${elapsed}</b><br/><br/>
             ${T[lang].best}: <b>${state.best}</b>`
          : `ğŸ˜µ <b>${T[lang].loseTitle}</b><br/>
             Ù†ØªÙŠØ¬ØªÙƒ: <b>${state.score}</b><br/>
             Ø§Ù„ØªÙØ§Ø­: <b>${state.statA}</b> â€¢ Ø§Ù„Ø·ÙˆÙ„: <b>${state.statB}</b><br/>
             ÙˆØµÙ„Øª Ù„Ù„Ù…Ø³ØªÙˆÙ‰: <b>${state.level}</b><br/>
             Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b><br/><br/>
             ${T[lang].best}: <b>${state.best}</b>`;

        showOverlay(
          `ğŸ ${T[lang].snake} â€” HM GAME`,
          msg,
          [
            { label: `ğŸ” ${T[lang].restart}`, primary:true, onClick: ()=>{ init(); hideOverlay(); state.startedAt=now(); } },
            { label: `ğŸ  ${T[lang].backMenu}`, danger:true, onClick: ()=>goMenu() }
          ]
        );
      }

      function win(){
        alive=false;
        setBest("snake", state.score);

        const elapsed = formatTime(now()-state.startedAt);
        const msg = (lang==="en")
          ? `ğŸ† <b>YOU WIN!</b><br/>
             Amazing! You dominated the board ğŸ˜„<br/><br/>
             Score: <b>${state.score}</b><br/>
             Apples: <b>${state.statA}</b> â€¢ Length: <b>${state.statB}</b><br/>
             Level: <b>${state.level}</b> â€¢ Time: <b>${elapsed}</b><br/><br/>
             ${T[lang].best}: <b>${state.best}</b>`
          : `ğŸ† <b>Ù„Ù‚Ø¯ Ø±Ø¨Ø­Øª!</b><br/>
             Ù…Ù…ØªØ§Ø²! Ø³ÙŠØ·Ø±Øª Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© ğŸ˜„<br/><br/>
             Ù†ØªÙŠØ¬ØªÙƒ: <b>${state.score}</b><br/>
             Ø§Ù„ØªÙØ§Ø­: <b>${state.statA}</b> â€¢ Ø§Ù„Ø·ÙˆÙ„: <b>${state.statB}</b><br/>
             Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <b>${state.level}</b> â€¢ Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b><br/><br/>
             ${T[lang].best}: <b>${state.best}</b>`;

        showOverlay(
          `ğŸ† ${T[lang].winTitle} â€” HM GAME`,
          msg,
          [
            { label: `ğŸ” ${T[lang].restart}`, primary:true, onClick: ()=>{ init(); hideOverlay(); state.startedAt=now(); } },
            { label: `ğŸ  ${T[lang].backMenu}`, danger:true, onClick: ()=>goMenu() }
          ]
        );
      }

      function update(dt){
        layout();
        if (!alive) return;

        tick += dt * speed;
        while (tick >= 1){
          tick -= 1;
          step();
          if (!alive) break;
        }
      }

      function draw(){
        layout();
        const w=canvas.width, h=canvas.height;

        // Background
        ctx.fillStyle = "#061025";
        ctx.fillRect(0,0,w,h);

        // Frame
        const lcdW = cell*GW, lcdH = cell*GH;
        ctx.fillStyle = css("--frame");
        roundRect(ox-10, oy-10, lcdW+20, lcdH+20, 18, true);

        // LCD gradient
        const g = ctx.createLinearGradient(0,oy,0,oy+lcdH);
        g.addColorStop(0, css("--lcd"));
        g.addColorStop(1, css("--lcd2"));
        ctx.fillStyle = g;
        roundRect(ox, oy, lcdW, lcdH, 12, true);

        // subtle scanlines
        ctx.fillStyle = "rgba(0,0,0,.06)";
        for (let y=0;y<GH;y++){
          ctx.fillRect(ox, oy+y*cell, lcdW, 1);
        }

        // Food
        drawPixel(food.x, food.y, 0.45);

        // Snake (head thicker)
        for (let i=0;i<snake.length;i++){
          const p=snake[i];
          const inset = (i===0) ? 0.10 : 0.16;
          drawBlock(p.x,p.y,inset);
        }

        // small title inside LCD
        ctx.fillStyle = "rgba(0,0,0,.32)";
        ctx.font = `${Math.floor(cell*1.05)}px system-ui`;
        ctx.textAlign = "left";
        ctx.fillText("HM GAME", ox+10, oy+24);
      }

      function drawPixel(x,y,scale){
        const px=ox + x*cell;
        const py=oy + y*cell;
        const s=Math.floor(cell*scale);
        ctx.fillStyle = css("--pixel");
        ctx.fillRect(px + ((cell-s)>>1), py + ((cell-s)>>1), s, s);
      }

      function drawBlock(x,y,insetRatio){
        const px=ox + x*cell;
        const py=oy + y*cell;
        const inset=Math.floor(cell*insetRatio);
        ctx.fillStyle = css("--pixel");
        ctx.fillRect(px+inset, py+inset, cell-inset*2, cell-inset*2);
      }

      function roundRect(x,y,w,h,r,fill){
        const rr=Math.min(r,w/2,h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
        if (fill) ctx.fill();
      }

      Snake.init = init;
      Snake.update = update;
      Snake.draw = draw;
    })();
// ==================================
    // ğŸ”´ BOUNCE (classic-ish Nokia style)
    // ==================================
    (function defineBounce(){
      const TILE = 24;

      // Tiles:
      // # solid brick
      // ^ spikes (death)
      // o ring (collect)
      // G gate (finish)
      // . empty
      const LEVELS = [
        [
          "........................................",
          "........................................",
          "..............o.........................",
          "............#####.......................",
          "........................................",
          "....o............................o......",
          "....###......................#####......",
          "........................................",
          "..................^.....................",
          "############......^......#############..",
          "........................................",
          "..............o.........................",
          ".............#####......................",
          "........................................",
          "###############################.....G...",
        ],
        [
          "........................................",
          "........................................",
          ".............o..........................",
          "..........#####.........................",
          "........................................",
          "....o..................^..........o.....",
          "....###..............#####.......###....",
          "........................................",
          "...............o........................",
          ".............#####......................",
          "........................................",
          "############.............#############..",
          "........................................",
          "..............o.........................",
          "###############################.....G...",
        ],
        [
          "........................................",
          "........................................",
          "....o..............o....................",
          "....###..........#####..................",
          "........................................",
          ".................^......................",
          ".................^......................",
          "############....###....###############..",
          "........................................",
          "..............o.........................",
          "............#####.......................",
          "........................................",
          "....o............................o......",
          "....###......................#####......",
          "###############################.....G...",
        ],
      ];

      let map = [];
      let wTiles=0, hTiles=0;
      let levelIndex = 0;

      // Player ball
      const ball = {
        x: 0, y: 0,
        vx: 0, vy: 0,
        r: 11,
      };

      // Camera
      let camX=0, camY=0;

      // Stats:
      // state.score: points (50 per ring)
      // state.statA: rings collected
      // state.statB: deaths
      // state.level: current level (1..n)
      let ringsTotal = 0;

      function init(){
        loadLevel(0);
      }

      function loadLevel(i){
        levelIndex = i;
        state.level = i+1;
        state.score = 0;
        state.statA = 0;
        state.statB = 0;
        setBest("bounce", 0);

        map = LEVELS[i].map(r=>r.split(""));
        hTiles = map.length;
        wTiles = map[0].length;

        // count rings
        ringsTotal = 0;
        for (let y=0;y<hTiles;y++) for (let x=0;x<wTiles;x++) if (map[y][x]==="o") ringsTotal++;

        // start pos
        ball.x = TILE*2;
        ball.y = TILE*3;
        ball.vx = 0;
        ball.vy = 0;

        camX=0; camY=0;
      }

      function tileAt(tx,ty){
        if (ty<0 || ty>=hTiles) return ".";
        if (tx<0 || tx>=wTiles) return ".";
        return map[ty][tx];
      }
      function setTile(tx,ty,v){
        if (ty<0 || ty>=hTiles) return;
        if (tx<0 || tx>=wTiles) return;
        map[ty][tx]=v;
      }
      function isSolid(tx,ty){ return tileAt(tx,ty)==="#"; }

      function circleRectColl(cx, cy, cr, rx, ry, rw, rh){
        const nx = clamp(cx, rx, rx+rw);
        const ny = clamp(cy, ry, ry+rh);
        const dx = cx - nx;
        const dy = cy - ny;
        return (dx*dx + dy*dy) <= cr*cr;
      }

      function collideSolids(cx,cy,cr){
        const L = Math.floor((cx-cr)/TILE);
        const R = Math.floor((cx+cr)/TILE);
        const Tt = Math.floor((cy-cr)/TILE);
        const B = Math.floor((cy+cr)/TILE);

        for (let ty=Tt; ty<=B; ty++){
          for (let tx=L; tx<=R; tx++){
            if (isSolid(tx,ty)){
              const rx=tx*TILE, ry=ty*TILE;
              if (circleRectColl(cx,cy,cr, rx,ry,TILE,TILE)) return true;
            }
          }
        }
        return false;
      }

      function resolveCollision(){
        // Push out from solids with small iterations (stable on mobile)
        const maxIter = 18;
        for (let i=0;i<maxIter;i++){
          if (!collideSolids(ball.x, ball.y, ball.r)) break;

          // try push up first then sideways
          ball.y -= 1;
          if (!collideSolids(ball.x, ball.y, ball.r)) { ball.vy = Math.min(ball.vy, 0); break; }

          ball.y += 1; // restore
          ball.x += (ball.vx>=0) ? -1 : 1;
          if (!collideSolids(ball.x, ball.y, ball.r)) { ball.vx = 0; break; }

          // final fallback
          ball.y -= 1;
        }
      }

      function update(dt){
        // Physics closer to Bounce feel: ball always bouncy
        const accel = 1200;
        const maxVx = 520;
        const gravity = 1600;
        const airDrag = 0.995;
        const bounce = 0.72;   // restitution
        const groundFriction = 0.985;

        // input -> acceleration
        if (input.bounceLeft)  ball.vx -= accel*dt;
        if (input.bounceRight) ball.vx += accel*dt;
        ball.vx = clamp(ball.vx, -maxVx, maxVx);

        // gravity
        ball.vy += gravity*dt;

        // integrate
        ball.x += ball.vx*dt;
        ball.y += ball.vy*dt;

        // damping
        ball.vx *= Math.pow(airDrag, dt*60);
        ball.vy *= Math.pow(airDrag, dt*60);

        // collision with solids
        if (collideSolids(ball.x, ball.y, ball.r)){
          // simple rebound: invert velocity based on which axis likely hit
          // test x-only and y-only
          const xOnly = collideSolids(ball.x - ball.vx*dt, ball.y, ball.r);
          const yOnly = collideSolids(ball.x, ball.y - ball.vy*dt, ball.r);

          if (yOnly && !xOnly){
            ball.vy = -ball.vy * bounce;
            ball.vx *= groundFriction;
          } else if (xOnly && !yOnly){
            ball.vx = -ball.vx * bounce;
          } else {
            ball.vy = -ball.vy * bounce;
            ball.vx = -ball.vx * bounce * 0.6;
          }
          resolveCollision();
        }

        // fall out of world => lose
        if (ball.y > hTiles*TILE + 400) {
          die();
          return;
        }

        // pickups/hazards
        handleInteract();

        // camera follow
        const viewW = canvas.width, viewH = canvas.height;
        const mapW = wTiles*TILE, mapH = hTiles*TILE;
        camX = clamp(ball.x - viewW*0.5, 0, Math.max(0, mapW - viewW));
        camY = clamp(ball.y - viewH*0.55, 0, Math.max(0, mapH - viewH));
      }

      function handleInteract(){
        const tx = Math.floor(ball.x / TILE);
        const ty = Math.floor(ball.y / TILE);

        for (let y=ty-1;y<=ty+1;y++){
          for (let x=tx-1;x<=tx+1;x++){
            const t = tileAt(x,y);
            const rx=x*TILE, ry=y*TILE;

            if (t==="o"){
              // ring
              if (circleRectColl(ball.x, ball.y, ball.r, rx+6, ry+6, TILE-12, TILE-12)){
                setTile(x,y,".");
                state.statA += 1;
                state.score += 50;
                setBest("bounce", state.score);
              }
            }

            if (t==="^"){
              // spikes
              if (circleRectColl(ball.x, ball.y, ball.r, rx,ry,TILE,TILE)){
                die();
                return;
              }
            }

            if (t==="G"){
              if (circleRectColl(ball.x, ball.y, ball.r, rx,ry,TILE,TILE)){
                nextLevelOrWin();
                return;
              }
            }
          }
        }
      }

      function die(){
        state.statB += 1;
        // restart same level, keep score? original usually keeps score; we'll keep score.
        const elapsed = formatTime(now()-state.startedAt);

        showOverlay(
          `ğŸ”´ ${T[lang].bounce} â€” HM GAME`,
          (lang==="en")
            ? `ğŸ˜µ <b>${T[lang].loseTitle}</b><br/>
               Level: <b>${state.level}</b><br/>
               Score: <b>${state.score}</b><br/>
               Rings: <b>${state.statA}/${ringsTotal}</b><br/>
               Deaths: <b>${state.statB}</b><br/>
               Time: <b>${elapsed}</b><br/><br/>
               ${T[lang].best}: <b>${state.best}</b>`
            : `ğŸ˜µ <b>${T[lang].loseTitle}</b><br/>
               Ø§Ù„Ù…Ø±Ø­Ù„Ø©: <b>${state.level}</b><br/>
               Ø§Ù„Ù†ØªÙŠØ¬Ø©: <b>${state.score}</b><br/>
               Ø§Ù„Ø­Ù„Ù‚Ø§Øª: <b>${state.statA}/${ringsTotal}</b><br/>
               Ù…Ø±Ø§Øª Ø§Ù„Ø®Ø³Ø§Ø±Ø©: <b>${state.statB}</b><br/>
               Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b><br/><br/>
               ${T[lang].best}: <b>${state.best}</b>`,
          [
            { label: `ğŸ” ${T[lang].restart}`, primary:true, onClick: ()=>{ // restart level
              const keepScore = state.score;
              const keepRings = state.statA;
              const keepDeaths = state.statB;
              loadLevel(levelIndex);
              state.score = keepScore;
              state.statA = keepRings;
              state.statB = keepDeaths;
              hideOverlay();
            }},
            { label: `ğŸ  ${T[lang].backMenu}`, danger:true, onClick: ()=>goMenu() }
          ]
        );

        // reset ball position (soft)
        ball.x = TILE*2;
        ball.y = TILE*3;
        ball.vx = 0;
        ball.vy = 0;
      }

      function nextLevelOrWin(){
        const elapsed = formatTime(now()-state.startedAt);

        if (levelIndex + 1 < LEVELS.length){
          showOverlay(
            "âœ… HM GAME",
            (lang==="en")
              ? `ğŸ‰ Level cleared!<br/>
                 Level: <b>${state.level}</b> â†’ <b>${state.level+1}</b><br/>
                 Score: <b>${state.score}</b><br/>
                 Rings: <b>${state.statA}/${ringsTotal}</b><br/>
                 Time: <b>${elapsed}</b>`
              : `ğŸ‰ ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©!<br/>
                 Ø§Ù„Ù…Ø±Ø­Ù„Ø©: <b>${state.level}</b> â†’ <b>${state.level+1}</b><br/>
                 Ø§Ù„Ù†ØªÙŠØ¬Ø©: <b>${state.score}</b><br/>
                 Ø§Ù„Ø­Ù„Ù‚Ø§Øª: <b>${state.statA}/${ringsTotal}</b><br/>
                 Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b>`,
            [
              { label: "â¡ï¸ Next", primary:true, onClick: ()=>{
                const keepScore = state.score;
                const keepDeaths = state.statB;
                loadLevel(levelIndex+1);
                state.score = keepScore;
                state.statB = keepDeaths;
                hideOverlay();
              }},
              { label: `ğŸ” ${T[lang].restart}`, onClick: ()=>{ loadLevel(levelIndex); hideOverlay(); } },
              { label: `ğŸ  ${T[lang].backMenu}`, danger:true, onClick: ()=>goMenu() }
            ]
          );
        } else {
          // WIN!
          setBest("bounce", state.score);
          showOverlay(
            `ğŸ† ${T[lang].winTitle} â€” HM GAME`,
            (lang==="en")
              ? `ğŸ† <b>YOU WIN!</b><br/>
                 You finished all levels! ğŸ˜„<br/><br/>
                 Final Score: <b>${state.score}</b><br/>
                 Total Rings: <b>${state.statA}</b><br/>
                 Deaths: <b>${state.statB}</b><br/>
                 Time: <b>${elapsed}</b><br/><br/>
                 ${T[lang].best}: <b>${state.best}</b>`
              : `ğŸ† <b>Ù„Ù‚Ø¯ Ø±Ø¨Ø­Øª!</b><br/>
                 Ø£Ù†Ù‡ÙŠØª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„! ğŸ˜„<br/><br/>
                 Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: <b>${state.score}</b><br/>
                 Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø­Ù„Ù‚Ø§Øª: <b>${state.statA}</b><br/>
                 Ù…Ø±Ø§Øª Ø§Ù„Ø®Ø³Ø§Ø±Ø©: <b>${state.statB}</b><br/>
                 Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b><br/><br/>
                 ${T[lang].best}: <b>${state.best}</b>`,
            [
              { label: `ğŸ” ${T[lang].restart}`, primary:true, onClick: ()=>{ loadLevel(0); hideOverlay(); state.startedAt=now(); } },
              { label: `ğŸ  ${T[lang].backMenu}`, danger:true, onClick: ()=>goMenu() }
            ]
          );
        }
      }

      function draw(){
        // sky
        ctx.fillStyle = css("--sky");
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // clouds (parallax)
        ctx.fillStyle = "rgba(255,255,255,.35)";
        for (let i=0;i<6;i++){
          const x = ((i*280 + camX*0.15) % (canvas.width+320)) - 160;
          const y = 70 + i*42;
          roundRect(x,y,150,36,18,true);
        }

        const startTx = Math.floor(camX/TILE);
        const endTx = Math.ceil((camX+canvas.width)/TILE);
        const startTy = Math.floor(camY/TILE);
        const endTy = Math.ceil((camY+canvas.height)/TILE);

        for (let ty=startTy; ty<endTy; ty++){
          for (let tx=startTx; tx<endTx; tx++){
            const t = tileAt(tx,ty);
            const x = tx*TILE - camX;
            const y = ty*TILE - camY;

            if (t==="#") drawBrick(x,y);
            else if (t==="o") drawRing(x,y);
            else if (t==="^") drawSpike(x,y);
            else if (t==="G") drawGate(x,y);
          }
        }

        // ball
        drawBall(ball.x - camX, ball.y - camY, ball.r);

        // HUD details line (extra)
        const rings = `${state.statA}/${ringsTotal}`;
        // Put Bounce-specific info into hudStat1/hudStat2 via updateHUD? keep simple:
        // We'll update hudStat1/hudStat2 by score/best already.
        // Add tiny top-left text on canvas for rings:
        ctx.fillStyle = "rgba(0,0,0,.25)";
        ctx.font = `${Math.floor(Math.min(canvas.width,canvas.height)*0.032)}px system-ui`;
        ctx.textAlign = "left";
        ctx.fillText(`Rings: ${rings}`, 14, 34);
      }

      function drawBall(x,y,r){
        ctx.fillStyle = "rgba(0,0,0,.18)";
        ctx.beginPath();
        ctx.ellipse(x, y + r*0.85, r*1.05, r*0.35, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = css("--ball");
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,.30)";
        ctx.beginPath();
        ctx.arc(x - r*0.35, y - r*0.35, r*0.35, 0, Math.PI*2);
        ctx.fill();
      }

      function drawBrick(x,y){
        ctx.fillStyle = css("--brick");
        ctx.fillRect(x,y,TILE,TILE);
        ctx.fillStyle = "rgba(255,255,255,.10)";
        ctx.fillRect(x+2,y+2,TILE-4,5);
        ctx.fillStyle = "rgba(0,0,0,.12)";
        ctx.fillRect(x+2,y+TILE-6,TILE-4,4);

        ctx.strokeStyle = css("--brick2");
        ctx.lineWidth = 2;
        ctx.strokeRect(x+1,y+1,TILE-2,TILE-2);
      }

      function drawRing(x,y){
        ctx.strokeStyle = css("--ring");
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(x+TILE/2,y+TILE/2,TILE*0.28,0,Math.PI*2);
        ctx.stroke();

        ctx.strokeStyle = "rgba(255,255,255,.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x+TILE/2-1,y+TILE/2-2,TILE*0.22,0,Math.PI*2);
        ctx.stroke();
      }

      function drawSpike(x,y){
        ctx.fillStyle = css("--spike");
        ctx.beginPath();
        ctx.moveTo(x, y+TILE);
        ctx.lineTo(x+TILE*0.25, y+TILE*0.35);
        ctx.lineTo(x+TILE*0.5, y+TILE);
        ctx.lineTo(x+TILE*0.75, y+TILE*0.35);
        ctx.lineTo(x+TILE, y+TILE);
        ctx.closePath();
        ctx.fill();
      }

      function drawGate(x,y){
        // white gate like finish
        ctx.fillStyle = "rgba(0,0,0,.18)";
        roundRect(x+2,y+2,TILE-4,TILE-4,7,true);

        ctx.strokeStyle = css("--gate");
        ctx.lineWidth = 2;
        roundRectStroke(x+4,y+4,TILE-8,TILE-8,6);

        ctx.fillStyle = "rgba(255,255,255,.85)";
        ctx.font = `${Math.floor(TILE*0.62)}px system-ui`;
        ctx.textAlign = "center";
        ctx.fillText("G", x+TILE/2, y+TILE*0.73);
      }

      function roundRect(x,y,w,h,r,fill){
        const rr = Math.min(r,w/2,h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
        if (fill) ctx.fill();
      }
      function roundRectStroke(x,y,w,h,r){
        const rr = Math.min(r,w/2,h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
        ctx.stroke();
      }

      Bounce.init = init;
      Bounce.update = update;
      Bounce.draw = draw;
    })();
// ===== End of HM GAME =====
  })();
  </script>

</body>
</html>