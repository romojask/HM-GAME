<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#0b1220" />
  <title>HM GAME</title>
</head>

<body>
  <!-- TOP BAR -->
  <header class="hmTopbar">
    <div class="hmBrand">
      <div class="hmLogo">HM</div>
      <div class="hmBrandTxt">
        <div class="hmTitle">HM GAME ğŸ®</div>
        <div class="hmSub" id="subTitle">Choose a game</div>
      </div>
    </div>

    <div class="hmActions">
      <button class="hmBtn" id="btnLang" title="Language">AR</button>
      <button class="hmBtn" id="btnMenu" title="Menu">Menu</button>
      <button class="hmBtn" id="btnPause" title="Pause">Pause</button>
      <button class="hmBtn hmPrimary" id="btnRestart" title="Restart">Restart</button>
    </div>
  </header>

  <!-- MAIN: GAME (TOP) + CONTROLS (BOTTOM) -->
  <main class="hmMain">
    <!-- GAME AREA -->
    <section class="hmGameArea">
      <canvas id="cv"></canvas>

      <!-- HUD (top overlay inside game area) -->
      <div class="hmHud">
        <div class="hmHudLeft">
          <span class="hmPill" id="hudBrand">HM GAME</span>
          <span class="hmPill" id="hudMode">â€”</span>
          <span class="hmPill" id="hudExtra"> </span>
        </div>
        <div class="hmHudRight">
          <span class="hmPill" id="hudScore">Score: 0</span>
          <span class="hmPill" id="hudBest">Best: 0</span>
          <span class="hmPill" id="hudTime">00:00</span>
        </div>
      </div>

      <!-- CENTER OVERLAY (pause / win / lose / results) -->
      <div class="hmOverlay" id="overlay" hidden>
        <div class="hmCard">
          <div class="hmCardTitle" id="ovTitle">HM GAME</div>
          <div class="hmCardText" id="ovText">...</div>
          <div class="hmCardActions" id="ovActions"></div>
        </div>
      </div>
    </section>

    <!-- CONTROLS AREA (fixed height) -->
    <section class="hmControlsArea">
      <!-- MENU VIEW (game selection) -->
      <div class="hmMenuView" id="menuView">
        <div class="hmMenuHead">
          <div class="hmMenuHeadTitle" id="menuTitle">HM GAME âœ¨</div>
          <div class="hmMenuHeadText" id="menuText">
            Choose a game, then play using the buttons below.
          </div>
        </div>

        <div class="hmGameSelect">
          <button class="hmPick isActive" id="pickMenu" data-pick="menu">ğŸ  HM GAME</button>
          <button class="hmPick" id="pickSnake" data-pick="snake">ğŸ Snake</button>
          <button class="hmPick" id="pickBounce" data-pick="bounce">ğŸ”´ Bounce</button>
        </div>

        <div class="hmMenuCTA">
          <button class="hmBtn hmPrimary hmWide" id="btnStartSnake">ğŸ Start Snake</button>
          <button class="hmBtn hmWide" id="btnStartBounce">ğŸ”´ Start Bounce</button>
        </div>

        <div class="hmHint" id="menuHint">
          Tip: Keyboard works too (WASD / Arrows). âœ…
        </div>
      </div>

      <!-- SNAKE CONTROLS -->
      <div class="hmPlayView" id="snakeView" hidden>
        <div class="hmControlsRow">
          <div class="hmDpad">
            <button class="hmPad" data-act="su">â–²</button>
            <div class="hmDpadMid">
              <button class="hmPad" data-act="sl">â—€</button>
              <button class="hmPad hmPadCenter" data-act="noop">HM</button>
              <button class="hmPad" data-act="sr">â–¶</button>
            </div>
            <button class="hmPad" data-act="sd">â–¼</button>
          </div>

          <div class="hmSide">
            <button class="hmBtn hmWide" data-act="pause">â¸ï¸ Pause</button>
            <button class="hmBtn hmWide hmDanger" data-act="exit">ğŸšª Exit</button>
          </div>
        </div>
      </div>

      <!-- BOUNCE CONTROLS (LEFT/RIGHT like original) -->
      <div class="hmPlayView" id="bounceView" hidden>
        <div class="hmControlsRow">
          <div class="hmBounceRow">
            <button class="hmBtn hmWide" data-act="bl">â—€ Left</button>
            <button class="hmBtn hmWide hmPrimary" data-act="pause">â¸ï¸ Pause</button>
            <button class="hmBtn hmWide" data-act="br">Right â–¶</button>
          </div>

          <div class="hmSide">
            <button class="hmBtn hmWide" data-act="restart">ğŸ” Restart</button>
            <button class="hmBtn hmWide hmDanger" data-act="exit">ğŸšª Exit</button>
          </div>
        </div>
      </div>

      <div class="hmFooter">Â© HM GAME</div>
    </section>
  </main>
<style>
    :root{
      --bg:#0b1220;
      --panel:#111a2a;
      --panel2:#0f1726;
      --text:#eaf1ff;
      --muted:#a7b7de;
      --line:rgba(255,255,255,.10);
      --accent:#4ea1ff;
      --danger:#ff4e6a;

      /* Bounce colors */
      --sky:#6fd4ff;
      --brick:#b55a2d;
      --brick2:#8f3d1f;
      --ring:#ffd34f;
      --ball:#e83535;
      --spike:#1b2338;
      --gate:#ffffff;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 800px at 80% 20%, #15244b, var(--bg));
      color:var(--text);
      overflow:hidden; /* IMPORTANT: fill phone, no scroll */
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* Topbar */
    .hmTopbar{
      height: 64px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: color-mix(in oklab, var(--panel) 92%, black);
      border-bottom: 1px solid var(--line);
      padding-top: calc(10px + env(safe-area-inset-top));
    }

    .hmBrand{ display:flex; align-items:center; gap:10px; min-width: 160px; }
    .hmLogo{
      width:42px; height:42px;
      display:grid; place-items:center;
      border-radius: 12px;
      font-weight:1000;
      background: rgba(78,161,255,.18);
      border: 1px solid rgba(78,161,255,.55);
      flex: 0 0 auto;
    }
    .hmTitle{ font-weight:1000; font-size:16px; }
    .hmSub{ color:var(--muted); font-size:12px; margin-top:2px; }

    .hmActions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .hmBtn{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      line-height: 1;
      white-space: nowrap;
    }
    .hmBtn:active{ transform: translateY(1px); }
    .hmPrimary{
      background: rgba(78,161,255,.18);
      border-color: rgba(78,161,255,.55);
    }
    .hmDanger{
      background: rgba(255,78,106,.12);
      border-color: rgba(255,78,106,.55);
    }
    .hmWide{ width:100%; }

    /* Main layout: BIG GAME TOP + FIXED CONTROLS BOTTOM */
    .hmMain{
      height: calc(100dvh - 64px - env(safe-area-inset-top));
      display:grid;
      grid-template-rows: 1fr auto;
    }

    /* Controls height: fixed-ish and phone-friendly */
    .hmControlsArea{
      height: clamp(240px, 34dvh, 360px);
      padding: 12px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      background: color-mix(in oklab, var(--panel) 92%, black);
      border-top: 1px solid var(--line);
    }

    .hmGameArea{
      position:relative;
      background: #061025;
    }
    #cv{
      width:100%;
      height:100%;
      display:block;
      background: #061025;
    }

    /* HUD */
    .hmHud{
      position:absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
    }
    .hmHudLeft,.hmHudRight{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .hmPill{
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.16);
      font-size: 12px;
      font-weight: 900;
      backdrop-filter: blur(8px);
    }

    /* Center overlay */
    .hmOverlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 16px;
      background: rgba(0,0,0,.38);
    }
    .hmCard{
      width: min(560px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(17,26,42,.94);
      padding: 14px;
      box-shadow: 0 22px 70px rgba(0,0,0,.45);
    }
    .hmCardTitle{ font-size: 18px; font-weight: 1000; margin-bottom: 6px; }
    .hmCardText{ color: var(--muted); font-size: 13px; line-height: 1.7; }
    .hmCardActions{ display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; }

    /* Menu view */
    .hmMenuHeadTitle{ font-weight:1000; margin-bottom:4px; }
    .hmMenuHeadText{ color:var(--muted); font-size:13px; line-height:1.6; }

    .hmGameSelect{
      display:flex;
      gap:10px;
      margin-top: 10px;
      flex-wrap:wrap;
    }
    .hmPick{
      flex:1 1 120px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 1000;
      cursor:pointer;
      user-select:none;
      text-align:center;
    }
    .hmPick.isActive{
      border-color: rgba(78,161,255,.60);
      background: rgba(78,161,255,.14);
    }

    .hmMenuCTA{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top: 12px;
    }
    .hmHint{
      margin-top: 10px;
      color: rgba(255,255,255,.60);
      font-size: 12px;
      text-align:center;
    }

    /* Play controls */
    .hmControlsRow{
      display:flex;
      gap: 12px;
      align-items: stretch;
      height: calc(100% - 20px);
    }
    .hmDpad{
      flex: 1 1 220px;
      display:grid;
      gap:8px;
      justify-items:center;
      padding: 8px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .hmDpadMid{ display:flex; gap:8px; }
    .hmPad{
      width: 64px;
      height: 56px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-weight: 1000;
      font-size: 20px;
      cursor:pointer;
      user-select:none;
    }
    .hmPad:active{ transform: translateY(1px); }
    .hmPadCenter{
      border-color: rgba(78,161,255,.55);
      background: rgba(78,161,255,.14);
    }
    .hmSide{
      flex: 1 1 170px;
      display:grid;
      gap:10px;
    }
    .hmBounceRow{
      flex: 1 1 320px;
      display:flex;
      gap:10px;
      align-items: stretch;
    }
    .hmFooter{
      margin-top: 10px;
      text-align:center;
      color: rgba(255,255,255,.55);
      font-size: 12px;
    }

    @media (max-width: 420px){
      .hmBtn{ padding: 9px 10px; }
      .hmPad{ width: 60px; height: 54px; }
      .hmControlsArea{ height: clamp(230px, 36dvh, 360px); }
    }
  </style>
<script>
  (() => {
    "use strict";

    const cv = document.getElementById("cv");
    const ctx = cv.getContext("2d", { alpha:false });

    const subTitle = document.getElementById("subTitle");
    const btnLang = document.getElementById("btnLang");
    const btnMenu = document.getElementById("btnMenu");
    const btnPause = document.getElementById("btnPause");
    const btnRestart = document.getElementById("btnRestart");

    const hudMode = document.getElementById("hudMode");
    const hudExtra = document.getElementById("hudExtra");
    const hudScore = document.getElementById("hudScore");
    const hudBest  = document.getElementById("hudBest");
    const hudTime  = document.getElementById("hudTime");

    const overlay = document.getElementById("overlay");
    const ovTitle = document.getElementById("ovTitle");
    const ovText  = document.getElementById("ovText");
    const ovActions = document.getElementById("ovActions");

    const menuView = document.getElementById("menuView");
    const snakeView = document.getElementById("snakeView");
    const bounceView = document.getElementById("bounceView");

    const menuTitle = document.getElementById("menuTitle");
    const menuText  = document.getElementById("menuText");
    const menuHint  = document.getElementById("menuHint");

    const pickMenu = document.getElementById("pickMenu");
    const pickSnake = document.getElementById("pickSnake");
    const pickBounce = document.getElementById("pickBounce");

    const btnStartSnake = document.getElementById("btnStartSnake");
    const btnStartBounce = document.getElementById("btnStartBounce");

    // ---------- Utils ----------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const now = ()=>performance.now();
    const pad2 = (n)=>String(n).padStart(2,"0");
    const css = (v)=>getComputedStyle(document.documentElement).getPropertyValue(v).trim();

    function fmtTime(ms){
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const r = s%60;
      return `${pad2(m)}:${pad2(r)}`;
    }

    function resize(){
      const rect = cv.getBoundingClientRect();
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (cv.width !== w || cv.height !== h) { cv.width = w; cv.height = h; }
    }
    window.addEventListener("resize", resize);

    // ---------- Language ----------
    const LANG_KEY = "HM_GAME_LANG";
    let lang = (localStorage.getItem(LANG_KEY) || "en"); // en|ar

    const T = {
      en:{
        choose:"Choose a game",
        menu:"Menu",
        pause:"Pause",
        resume:"Resume",
        restart:"Restart",
        exit:"Exit",
        startSnake:"ğŸ Start Snake",
        startBounce:"ğŸ”´ Start Bounce",
        snake:"Snake",
        bounce:"Bounce",
        tip:"Tip: Keyboard works too (WASD / Arrows). âœ…",
        menuText:"Choose a game, then play using the buttons below.",
        pausedTitle:"â¸ï¸ HM GAME â€” Paused",
        pausedText:"Game is paused.<br/>Press Resume to continue.",
        backMenu:"ğŸ  Back to Menu",
        youWin:"ğŸ† YOU WIN!",
        gameOver:"ğŸ˜µ Game Over",
        best:"Best",
        results:"Results",
      },
      ar:{
        choose:"Ø§Ø®ØªØ± Ù„Ø¹Ø¨Ø©",
        menu:"Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©",
        pause:"ØªÙˆÙ‚Ù Ù…Ø¤Ù‚Øª",
        resume:"Ù…ØªØ§Ø¨Ø¹Ø©",
        restart:"Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„",
        exit:"Ø®Ø±ÙˆØ¬",
        startSnake:"ğŸ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†",
        startBounce:"ğŸ”´ ØªØ´ØºÙŠÙ„ Ø¨Ø§ÙˆÙ†Ø³",
        snake:"Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†",
        bounce:"Ø¨Ø§ÙˆÙ†Ø³",
        tip:"Ù…Ù„Ø§Ø­Ø¸Ø©: ÙŠØ¯Ø¹Ù… Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø£ÙŠØ¶Ù‹Ø§ (WASD / Ø§Ù„Ø£Ø³Ù‡Ù…). âœ…",
        menuText:"Ø§Ø®ØªØ± Ù„Ø¹Ø¨Ø© Ø«Ù… Ø§Ù„Ø¹Ø¨ Ø¨Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø£Ø³ÙÙ„.",
        pausedTitle:"â¸ï¸ HM GAME â€” Ù…ØªÙˆÙ‚Ù",
        pausedText:"Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØªÙˆÙ‚ÙØ© Ù…Ø¤Ù‚ØªÙ‹Ø§.<br/>Ø§Ø¶ØºØ· Ù…ØªØ§Ø¨Ø¹Ø© Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù„Ø¹Ø¨.",
        backMenu:"ğŸ  Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©",
        youWin:"ğŸ† Ù„Ù‚Ø¯ Ø±Ø¨Ø­Øª!",
        gameOver:"ğŸ˜µ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©",
        best:"Ø£ÙØ¶Ù„",
        results:"Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
      }
    };

    function applyLang(){
      document.documentElement.lang = lang;
      document.documentElement.dir  = (lang==="ar") ? "rtl" : "ltr";

      btnLang.textContent = (lang==="ar") ? "EN" : "AR";
      btnMenu.textContent = T[lang].menu;
      btnRestart.textContent = T[lang].restart;

      menuTitle.textContent = "HM GAME âœ¨";
      menuText.textContent  = T[lang].menuText;
      menuHint.textContent  = T[lang].tip;

      pickMenu.textContent = "ğŸ  HM GAME";
      pickSnake.textContent = `ğŸ ${T[lang].snake}`;
      pickBounce.textContent = `ğŸ”´ ${T[lang].bounce}`;

      btnStartSnake.textContent = T[lang].startSnake;
      btnStartBounce.textContent = T[lang].startBounce;

      // pause text depends on state
      btnPause.textContent = state.paused ? T[lang].resume : T[lang].pause;

      // if overlay is showing, refresh it when needed
      if (!overlay.hidden) refreshOverlay();
      subTitle.textContent = (state.game==="menu") ? T[lang].choose : subTitle.textContent;
    }

    btnLang.addEventListener("click", ()=>{
      lang = (lang==="en") ? "ar" : "en";
      localStorage.setItem(LANG_KEY, lang);
      applyLang();
    });

    // ---------- Best storage ----------
    const BEST_KEY = "HM_GAME_BESTS";
    const bests = (()=>{ try{return JSON.parse(localStorage.getItem(BEST_KEY)||"{}");}catch{return{};} })();
    function getBest(k){ return bests[k] ?? 0; }
    function setBest(k, v){
      if ((bests[k] ?? 0) < v){
        bests[k] = v;
        localStorage.setItem(BEST_KEY, JSON.stringify(bests));
      }
      state.best = getBest(k);
    }

    // ---------- State ----------
    const state = {
      game:"menu",       // menu|snake|bounce
      paused:false,
      startedAt:0,
      score:0,
      best:0,
      level:1,
      extra:"",          // HUD extra text (rings/lives/apples...)
      // per-game stats:
      a:0, b:0, c:0
    };

    // ---------- Input ----------
    const input = {
      // snake dir queue
      sDir:null,
      // bounce holds
      bLeft:false,
      bRight:false,
      // one-shots
      pause:false,
      restart:false,
      exit:false
    };

    function bindHold(el, onDown, onUp){
      el.addEventListener("pointerdown",(e)=>{ e.preventDefault(); onDown?.(); });
      el.addEventListener("pointerup",(e)=>{ e.preventDefault(); onUp?.(); });
      el.addEventListener("pointercancel",(e)=>{ e.preventDefault(); onUp?.(); });
      el.addEventListener("pointerleave",(e)=>{ e.preventDefault(); onUp?.(); });
    }

    function queueSnake(x,y){ input.sDir = {x,y}; }

    document.querySelectorAll("[data-act]").forEach(btn=>{
      const a = btn.dataset.act;
      if (a==="su") bindHold(btn, ()=>queueSnake(0,-1));
      if (a==="sd") bindHold(btn, ()=>queueSnake(0, 1));
      if (a==="sl") bindHold(btn, ()=>queueSnake(-1,0));
      if (a==="sr") bindHold(btn, ()=>queueSnake(1,0));

      if (a==="pause") bindHold(btn, ()=>input.pause=true);
      if (a==="restart") bindHold(btn, ()=>input.restart=true);
      if (a==="exit") bindHold(btn, ()=>input.exit=true);

      if (a==="bl") bindHold(btn, ()=>input.bLeft=true, ()=>input.bLeft=false);
      if (a==="br") bindHold(btn, ()=>input.bRight=true, ()=>input.bRight=false);
    });

    // keyboard
    window.addEventListener("keydown",(e)=>{
      const k = e.key.toLowerCase();
      if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();

      if (state.game==="snake"){
        if (k==="arrowup"||k==="w") queueSnake(0,-1);
        if (k==="arrowdown"||k==="s") queueSnake(0, 1);
        if (k==="arrowleft"||k==="a") queueSnake(-1,0);
        if (k==="arrowright"||k==="d") queueSnake(1,0);
      }
      if (state.game==="bounce"){
        if (k==="arrowleft"||k==="a") input.bLeft=true;
        if (k==="arrowright"||k==="d") input.bRight=true;
      }

      if (k==="p") input.pause=true;
      if (k==="r") input.restart=true;
      if (k==="escape") input.exit=true;
    },{passive:false});

    window.addEventListener("keyup",(e)=>{
      const k = e.key.toLowerCase();
      if (state.game==="bounce"){
        if (k==="arrowleft"||k==="a") input.bLeft=false;
        if (k==="arrowright"||k==="d") input.bRight=false;
      }
    });

    // ---------- UI view switching ----------
    function setPickActive(which){
      [pickMenu,pickSnake,pickBounce].forEach(b=>b.classList.remove("isActive"));
      if (which==="menu") pickMenu.classList.add("isActive");
      if (which==="snake") pickSnake.classList.add("isActive");
      if (which==="bounce") pickBounce.classList.add("isActive");
    }

    function showViews(game){
      menuView.hidden = game!=="menu";
      snakeView.hidden = game!=="snake";
      bounceView.hidden = game!=="bounce";
    }

    pickMenu.addEventListener("click", ()=>goMenu());
    pickSnake.addEventListener("click", ()=>{ setPickActive("snake"); });
    pickBounce.addEventListener("click", ()=>{ setPickActive("bounce"); });

    btnStartSnake.addEventListener("click", ()=>startGame("snake"));
    btnStartBounce.addEventListener("click", ()=>startGame("bounce"));

    btnMenu.addEventListener("click", ()=>goMenu());
    btnPause.addEventListener("click", ()=>input.pause=true);
    btnRestart.addEventListener("click", ()=>input.restart=true);

    // ---------- Overlay ----------
    function showOverlay(title, html, actions){
      ovTitle.textContent = title;
      ovText.innerHTML = html;
      ovActions.innerHTML = "";
      actions.forEach(a=>{
        const b = document.createElement("button");
        b.className = "hmBtn " + (a.primary ? "hmPrimary" : "");
        if (a.danger) b.className += " hmDanger";
        b.textContent = a.label;
        b.addEventListener("click", a.onClick);
        ovActions.appendChild(b);
      });
      overlay.hidden = false;
    }
    function hideOverlay(){ overlay.hidden = true; }

    function refreshOverlay(){
      if (state.paused){
        showOverlay(
          T[lang].pausedTitle,
          T[lang].pausedText,
          [
            { label: T[lang].resume, primary:true, onClick: ()=>{ state.paused=false; hideOverlay(); } },
            { label: T[lang].restart, onClick: ()=>{ input.restart=true; hideOverlay(); } },
            { label: T[lang].backMenu, danger:true, onClick: ()=>goMenu() },
          ]
        );
      }
    }

    function togglePause(){
      if (state.game==="menu") return;
      state.paused = !state.paused;
      btnPause.textContent = state.paused ? T[lang].resume : T[lang].pause;
      if (state.paused) refreshOverlay();
      else hideOverlay();
    }

    // ---------- HUD ----------
    function updateHUD(){
      const elapsed = state.startedAt ? (now()-state.startedAt) : 0;
      hudTime.textContent = fmtTime(elapsed);

      if (state.game==="menu"){
        hudMode.textContent = "â€”";
        hudExtra.textContent = "";
        hudScore.textContent = "HM GAME";
        hudBest.textContent = "";
        return;
      }

      hudScore.textContent = `Score: ${state.score}`;
      hudBest.textContent  = `${T[lang].best}: ${state.best}`;
      hudExtra.textContent = state.extra || "";
      btnPause.textContent = state.paused ? T[lang].resume : T[lang].pause;

      if (state.game==="snake") hudMode.textContent = `ğŸ ${T[lang].snake} â€¢ Lv ${state.level}`;
      if (state.game==="bounce") hudMode.textContent = `ğŸ”´ ${T[lang].bounce} â€¢ Lv ${state.level}`;
    }

    // ---------- Game API placeholders (defined next parts) ----------
    const Snake = {};
    const Bounce = {};

    function goMenu(){
      state.game="menu";
      state.paused=false;
      state.startedAt=0;
      state.score=0;
      state.best=0;
      state.level=1;
      state.extra="";
      setPickActive("menu");
      showViews("menu");
      subTitle.textContent = T[lang].choose;
      hideOverlay();
      drawMenu();
      updateHUD();
    }

    function startGame(game){
      state.game = game;
      state.paused=false;
      state.startedAt = now();
      state.score=0;
      state.level=1;
      state.extra="";
      state.a=0; state.b=0; state.c=0;

      showViews(game);
      setPickActive(game);

      if (game==="snake"){
        state.best = getBest("snake");
        subTitle.textContent = (lang==="en") ? "Playing Snake" : "ØªÙ„Ø¹Ø¨ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†";
        Snake.init();
      } else {
        state.best = getBest("bounce");
        subTitle.textContent = (lang==="en") ? "Playing Bounce" : "ØªÙ„Ø¹Ø¨ Ø¨Ø§ÙˆÙ†Ø³";
        Bounce.init();
      }
      hideOverlay();
      updateHUD();
    }

    // ---------- Menu drawing ----------
    function drawMenu(){
      resize();
      ctx.fillStyle = "#061025";
      ctx.fillRect(0,0,cv.width,cv.height);

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.textAlign = "center";
      ctx.font = `${Math.floor(cv.width*0.08)}px system-ui`;
      ctx.fillText("HM GAME ğŸ®", cv.width/2, cv.height*0.40);

      ctx.fillStyle = "rgba(255,255,255,.70)";
      ctx.font = `${Math.floor(cv.width*0.04)}px system-ui`;
      ctx.fillText(lang==="en" ? "Pick a game below" : "Ø§Ø®ØªØ± Ù„Ø¹Ø¨Ø© Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„", cv.width/2, cv.height*0.52);
    }

    // ---------- Main Loop ----------
    let last = now();
    function loop(){
      resize();
      const t = now();
      const dt = clamp((t-last)/1000, 0, 0.04);
      last = t;

      if (input.pause){ input.pause=false; togglePause(); }
      if (input.exit){ input.exit=false; goMenu(); }

      if (state.game==="menu"){
        drawMenu();
      } else if (state.game==="snake"){
        if (input.restart){ input.restart=false; Snake.init(); state.paused=false; hideOverlay(); state.startedAt=now(); }
        if (!state.paused) Snake.update(dt);
        Snake.draw();
      } else if (state.game==="bounce"){
        if (input.restart){ input.restart=false; Bounce.init(); state.paused=false; hideOverlay(); state.startedAt=now(); }
        if (!state.paused) Bounce.update(dt);
        Bounce.draw();
      }

      updateHUD();
      requestAnimationFrame(loop);
    }

    // Start
    applyLang();
    goMenu();
    requestAnimationFrame(loop);
// =========================
    // ğŸ SNAKE (modern + smooth)
    // =========================
    (function defineSnake(){
      const GW = 24;
      const GH = 18;

      let cell=18, ox=0, oy=0;
      let snake=[], dir={x:1,y:0}, queued=null;
      let food={x:10,y:9};
      let tick=0;
      let speed=7;
      let alive=true;

      function layout(){
        const w=cv.width, h=cv.height;
        const pad=Math.floor(Math.min(w,h)*0.06);
        const uw=w-pad*2, uh=h-pad*2;
        cell = Math.max(10, Math.floor(Math.min(uw/GW, uh/GH)));
        ox = Math.floor((w - cell*GW)/2);
        oy = Math.floor((h - cell*GH)/2);
      }

      function init(){
        layout();
        snake = [
          {x:6,y:Math.floor(GH/2)},
          {x:5,y:Math.floor(GH/2)},
          {x:4,y:Math.floor(GH/2)},
        ];
        dir={x:1,y:0};
        queued=null;
        tick=0;
        speed=7;
        alive=true;

        state.score=0;
        state.a=0;              // apples
        state.b=snake.length;   // length
        state.level=1;
        setBest("snake", 0);

        placeFood();
        updateExtra();
      }

      function updateExtra(){
        // show apples + length
        state.extra = (lang==="en")
          ? `ğŸ ${state.a} â€¢ ğŸ§± Len ${state.b}`
          : `ğŸ ${state.a} â€¢ ğŸ§± Ø§Ù„Ø·ÙˆÙ„ ${state.b}`;
      }

      function placeFood(){
        for (let i=0;i<2000;i++){
          const fx = Math.floor(Math.random()*GW);
          const fy = Math.floor(Math.random()*GH);
          if (!snake.some(p=>p.x===fx && p.y===fy)){
            food={x:fx,y:fy};
            return;
          }
        }
        food={x:1,y:1};
      }

      function step(){
        if (!alive) return;

        if (input.sDir) queued=input.sDir;
        input.sDir=null;

        if (queued){
          const back = (queued.x===-dir.x && queued.y===-dir.y);
          if (!back) dir=queued;
          queued=null;
        }

        const head=snake[0];
        const nx=head.x+dir.x;
        const ny=head.y+dir.y;

        // wall hit = lose
        if (nx<0||nx>=GW||ny<0||ny>=GH){ lose(); return; }
        // self hit
        if (snake.some((p,i)=>i>0 && p.x===nx && p.y===ny)){ lose(); return; }

        snake.unshift({x:nx,y:ny});

        if (nx===food.x && ny===food.y){
          state.score += 10;
          state.a += 1;
          // speed level up every 5 apples
          state.level = 1 + Math.floor(state.a/5);
          speed = 7 + (state.level-1)*1.25;

          setBest("snake", state.score);
          placeFood();
        } else {
          snake.pop();
        }

        state.b = snake.length;
        updateExtra();

        // optional win condition (big domination)
        if (snake.length >= Math.floor(GW*GH*0.70)) win();
      }

      function lose(){
        alive=false;
        setBest("snake", state.score);

        const elapsed = fmtTime(now()-state.startedAt);
        const msg = (lang==="en")
          ? `<b>${T[lang].gameOver}</b><br/>
             Score: <b>${state.score}</b><br/>
             Apples: <b>${state.a}</b> â€¢ Length: <b>${state.b}</b><br/>
             Level: <b>${state.level}</b><br/>
             Time: <b>${elapsed}</b><br/><br/>
             ${T[lang].best}: <b>${state.best}</b>`
          : `<b>${T[lang].gameOver}</b><br/>
             Ø§Ù„Ù†ØªÙŠØ¬Ø©: <b>${state.score}</b><br/>
             Ø§Ù„ØªÙØ§Ø­: <b>${state.a}</b> â€¢ Ø§Ù„Ø·ÙˆÙ„: <b>${state.b}</b><br/>
             Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <b>${state.level}</b><br/>
             Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b><br/><br/>
             ${T[lang].best}: <b>${state.best}</b>`;

        showOverlay(
          `ğŸ ${T[lang].snake} â€” ${T[lang].results}`,
          msg,
          [
            { label:`ğŸ” ${T[lang].restart}`, primary:true, onClick:()=>{ init(); hideOverlay(); state.startedAt=now(); } },
            { label:T[lang].backMenu, danger:true, onClick:()=>goMenu() },
          ]
        );
      }

      function win(){
        alive=false;
        setBest("snake", state.score);

        const elapsed = fmtTime(now()-state.startedAt);
        const msg = (lang==="en")
          ? `ğŸ† <b>YOU WIN!</b><br/>
             You mastered the board ğŸ˜„<br/><br/>
             Score: <b>${state.score}</b><br/>
             Apples: <b>${state.a}</b> â€¢ Length: <b>${state.b}</b><br/>
             Level: <b>${state.level}</b> â€¢ Time: <b>${elapsed}</b><br/><br/>
             ${T[lang].best}: <b>${state.best}</b>`
          : `ğŸ† <b>Ù„Ù‚Ø¯ Ø±Ø¨Ø­Øª!</b><br/>
             Ø³ÙŠØ·Ø±Øª Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© ğŸ˜„<br/><br/>
             Ø§Ù„Ù†ØªÙŠØ¬Ø©: <b>${state.score}</b><br/>
             Ø§Ù„ØªÙØ§Ø­: <b>${state.a}</b> â€¢ Ø§Ù„Ø·ÙˆÙ„: <b>${state.b}</b><br/>
             Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <b>${state.level}</b> â€¢ Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b><br/><br/>
             ${T[lang].best}: <b>${state.best}</b>`;

        showOverlay(
          `ğŸ† ${T[lang].youWin}`,
          msg,
          [
            { label:`ğŸ” ${T[lang].restart}`, primary:true, onClick:()=>{ init(); hideOverlay(); state.startedAt=now(); } },
            { label:T[lang].backMenu, danger:true, onClick:()=>goMenu() },
          ]
        );
      }

      function update(dt){
        layout();
        if (!alive) return;

        tick += dt*speed;
        while (tick>=1){
          tick -= 1;
          step();
          if (!alive) break;
        }
      }

      function draw(){
        layout();
        const w=cv.width, h=cv.height;

        // background
        ctx.fillStyle = "#071735";
        ctx.fillRect(0,0,w,h);

        // board area with soft grid
        ctx.fillStyle = "rgba(255,255,255,.05)";
        roundRect(ox-8, oy-8, cell*GW+16, cell*GH+16, 18, true);

        ctx.fillStyle = "rgba(255,255,255,.03)";
        for (let y=0;y<GH;y++){
          ctx.fillRect(ox, oy+y*cell, cell*GW, 1);
        }
        for (let x=0;x<GW;x++){
          ctx.fillRect(ox+x*cell, oy, 1, cell*GH);
        }

        // food
        const fx = ox + food.x*cell + cell/2;
        const fy = oy + food.y*cell + cell/2;
        ctx.fillStyle = "#ffd34f";
        ctx.beginPath();
        ctx.arc(fx,fy, cell*0.25, 0, Math.PI*2);
        ctx.fill();

        // snake
        for (let i=0;i<snake.length;i++){
          const p = snake[i];
          const px = ox + p.x*cell;
          const py = oy + p.y*cell;

          const rr = Math.floor(cell*0.26);
          const inset = Math.floor(cell*0.12);
          ctx.fillStyle = (i===0) ? "#4ea1ff" : "rgba(78,161,255,.78)";
          roundRect(px+inset, py+inset, cell-inset*2, cell-inset*2, rr, true);

          // tiny shine
          if (i===0){
            ctx.fillStyle = "rgba(255,255,255,.25)";
            roundRect(px+inset+3, py+inset+3, (cell-inset*2)*0.45, (cell-inset*2)*0.25, rr, true);
          }
        }
      }

      function roundRect(x,y,w,h,r,fill){
        const rr=Math.min(r,w/2,h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
        if (fill) ctx.fill();
      }

      Snake.init = init;
      Snake.update = update;
      Snake.draw = draw;
    })();
// ==================================
    // ğŸ”´ BOUNCE (classic-ish + mobile HUD)
    // ==================================
    (function defineBounce(){
      const TILE = 24;

      // # bricks, ^ spikes, o ring, G gate, . empty
      const LEVELS = [
        [
          "........................................",
          "........................................",
          "..............o.........................",
          "............#####.......................",
          "........................................",
          "....o............................o......",
          "....###......................#####......",
          "........................................",
          "..................^.....................",
          "############......^......#############..",
          "........................................",
          "..............o.........................",
          ".............#####......................",
          "........................................",
          "###############################.....G...",
        ],
        [
          "........................................",
          "........................................",
          ".............o..........................",
          "..........#####.........................",
          "........................................",
          "....o..................^..........o.....",
          "....###..............#####.......###....",
          "........................................",
          "...............o........................",
          ".............#####......................",
          "........................................",
          "############.............#############..",
          "........................................",
          "..............o.........................",
          "###############################.....G...",
        ],
        [
          "........................................",
          "........................................",
          "....o..............o....................",
          "....###..........#####..................",
          "........................................",
          ".................^......................",
          ".................^......................",
          "############....###....###############..",
          "........................................",
          "..............o.........................",
          "............#####.......................",
          "........................................",
          "....o............................o......",
          "....###......................#####......",
          "###############################.....G...",
        ],
      ];

      let map=[], wTiles=0, hTiles=0;
      let levelIndex=0;
      let ringsTotal=0;

      const ball = { x:0, y:0, vx:0, vy:0, r:11 };
      let camX=0, camY=0;

      function init(){
        loadLevel(0, true);
      }

      function loadLevel(i, resetAll){
        levelIndex=i;
        state.level = i+1;

        if (resetAll){
          state.score = 0;
          state.a = 0; // rings collected (total across run)
          state.b = 3; // lives
          state.c = 0; // deaths
          setBest("bounce", 0);
        }

        map = LEVELS[i].map(r=>r.split(""));
        hTiles = map.length;
        wTiles = map[0].length;

        ringsTotal=0;
        for (let y=0;y<hTiles;y++) for (let x=0;x<wTiles;x++) if (map[y][x]==="o") ringsTotal++;

        // reset ball position
        ball.x = TILE*2;
        ball.y = TILE*3;
        ball.vx = 0;
        ball.vy = 0;

        camX=0; camY=0;
        updateExtra();
      }

      function updateExtra(){
        const hearts = "â¤ï¸".repeat(Math.max(0, state.b));
        const ringNow = `${ringsCollectedInLevel()}/${ringsTotal}`;
        state.extra = (lang==="en")
          ? `${hearts} â€¢ ğŸŸ¡ ${ringNow}`
          : `${hearts} â€¢ ğŸŸ¡ ${ringNow}`;
      }

      function ringsCollectedInLevel(){
        // rings left in map count
        let left=0;
        for (let y=0;y<hTiles;y++) for (let x=0;x<wTiles;x++) if (map[y][x]==="o") left++;
        return ringsTotal - left;
      }

      function tileAt(tx,ty){
        if (ty<0||ty>=hTiles) return ".";
        if (tx<0||tx>=wTiles) return ".";
        return map[ty][tx];
      }
      function setTile(tx,ty,v){
        if (ty<0||ty>=hTiles) return;
        if (tx<0||tx>=wTiles) return;
        map[ty][tx]=v;
      }
      function isSolid(tx,ty){ return tileAt(tx,ty)==="#"; }

      function circleRect(cx,cy,cr, rx,ry,rw,rh){
        const nx = clamp(cx, rx, rx+rw);
        const ny = clamp(cy, ry, ry+rh);
        const dx = cx-nx, dy = cy-ny;
        return (dx*dx + dy*dy) <= cr*cr;
      }

      function collideSolids(cx,cy,cr){
        const L=Math.floor((cx-cr)/TILE);
        const R=Math.floor((cx+cr)/TILE);
        const Tt=Math.floor((cy-cr)/TILE);
        const B=Math.floor((cy+cr)/TILE);

        for (let ty=Tt; ty<=B; ty++){
          for (let tx=L; tx<=R; tx++){
            if (isSolid(tx,ty)){
              const rx=tx*TILE, ry=ty*TILE;
              if (circleRect(cx,cy,cr, rx,ry,TILE,TILE)) return true;
            }
          }
        }
        return false;
      }

      function resolve(){
        for (let i=0;i<22;i++){
          if (!collideSolids(ball.x, ball.y, ball.r)) break;
          // push out gently
          ball.y -= 1;
          if (!collideSolids(ball.x, ball.y, ball.r)) { ball.vy = Math.min(ball.vy,0); break; }
          ball.y += 1;
          ball.x += (ball.vx>=0) ? -1 : 1;
          if (!collideSolids(ball.x, ball.y, ball.r)) { ball.vx = 0; break; }
          ball.y -= 1;
        }
      }

      function update(dt){
        // Physics: bouncy ball (close feel)
        const accel = 1200;
        const maxVx = 520;
        const gravity = 1600;
        const drag = 0.995;
        const bounce = 0.72;
        const groundFric = 0.985;

        if (input.bLeft) ball.vx -= accel*dt;
        if (input.bRight) ball.vx += accel*dt;
        ball.vx = clamp(ball.vx, -maxVx, maxVx);

        ball.vy += gravity*dt;

        ball.x += ball.vx*dt;
        ball.y += ball.vy*dt;

        ball.vx *= Math.pow(drag, dt*60);
        ball.vy *= Math.pow(drag, dt*60);

        if (collideSolids(ball.x, ball.y, ball.r)){
          const xOnly = collideSolids(ball.x - ball.vx*dt, ball.y, ball.r);
          const yOnly = collideSolids(ball.x, ball.y - ball.vy*dt, ball.r);

          if (yOnly && !xOnly){
            ball.vy = -ball.vy * bounce;
            ball.vx *= groundFric;
          } else if (xOnly && !yOnly){
            ball.vx = -ball.vx * bounce;
          } else {
            ball.vy = -ball.vy * bounce;
            ball.vx = -ball.vx * bounce * 0.6;
          }
          resolve();
        }

        // fall out => lose life
        if (ball.y > hTiles*TILE + 400){
          loseLife("fall");
          return;
        }

        interact();

        // camera follow
        const viewW=cv.width, viewH=cv.height;
        const mapW=wTiles*TILE, mapH=hTiles*TILE;
        camX = clamp(ball.x - viewW*0.5, 0, Math.max(0, mapW-viewW));
        camY = clamp(ball.y - viewH*0.55, 0, Math.max(0, mapH-viewH));

        updateExtra();
      }

      function interact(){
        const tx = Math.floor(ball.x / TILE);
        const ty = Math.floor(ball.y / TILE);

        for (let y=ty-1; y<=ty+1; y++){
          for (let x=tx-1; x<=tx+1; x++){
            const t = tileAt(x,y);
            const rx=x*TILE, ry=y*TILE;

            if (t==="o"){
              if (circleRect(ball.x,ball.y,ball.r, rx+6,ry+6, TILE-12,TILE-12)){
                setTile(x,y,".");
                state.score += 50;
                state.a += 1; // total rings
                setBest("bounce", state.score);
              }
            }

            if (t==="^"){
              if (circleRect(ball.x,ball.y,ball.r, rx,ry,TILE,TILE)){
                loseLife("spike");
                return;
              }
            }

            if (t==="G"){
              if (circleRect(ball.x,ball.y,ball.r, rx,ry,TILE,TILE)){
                finishLevel();
                return;
              }
            }
          }
        }
      }

      function loseLife(reason){
        state.b -= 1; // lives
        state.c += 1; // deaths
        updateExtra();

        if (state.b <= 0){
          // GAME OVER results
          setBest("bounce", state.score);
          const elapsed = fmtTime(now()-state.startedAt);
          const msg = (lang==="en")
            ? `<b>${T[lang].gameOver}</b><br/>
               Level: <b>${state.level}</b><br/>
               Score: <b>${state.score}</b><br/>
               Rings total: <b>${state.a}</b><br/>
               Deaths: <b>${state.c}</b><br/>
               Time: <b>${elapsed}</b><br/><br/>
               ${T[lang].best}: <b>${state.best}</b>`
            : `<b>${T[lang].gameOver}</b><br/>
               Ø§Ù„Ù…Ø±Ø­Ù„Ø©: <b>${state.level}</b><br/>
               Ø§Ù„Ù†ØªÙŠØ¬Ø©: <b>${state.score}</b><br/>
               Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø­Ù„Ù‚Ø§Øª: <b>${state.a}</b><br/>
               Ù…Ø±Ø§Øª Ø§Ù„Ø®Ø³Ø§Ø±Ø©: <b>${state.c}</b><br/>
               Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b><br/><br/>
               ${T[lang].best}: <b>${state.best}</b>`;

          showOverlay(
            `ğŸ”´ ${T[lang].bounce} â€” ${T[lang].results}`,
            msg,
            [
              { label:`ğŸ” ${T[lang].restart}`, primary:true, onClick:()=>{ init(); hideOverlay(); state.startedAt=now(); } },
              { label:T[lang].backMenu, danger:true, onClick:()=>goMenu() },
            ]
          );
          return;
        }

        // restart current level position (keep score/rings/lives)
        ball.x = TILE*2;
        ball.y = TILE*3;
        ball.vx = 0;
        ball.vy = 0;

        // small overlay info (optional, short)
        const txt = (lang==="en")
          ? `You lost a life! â¤ï¸ left: <b>${state.b}</b>`
          : `Ø®Ø³Ø±Øª Ø­ÙŠØ§Ø©! â¤ï¸ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <b>${state.b}</b>`;
        showOverlay(
          `ğŸ”´ ${T[lang].bounce}`,
          txt,
          [
            { label: (lang==="en") ? "Continue" : "Ù…ØªØ§Ø¨Ø¹Ø©", primary:true, onClick:()=>{ hideOverlay(); } },
          ]
        );
      }

      function finishLevel(){
        const elapsed = fmtTime(now()-state.startedAt);

        if (levelIndex + 1 < LEVELS.length){
          showOverlay(
            "âœ… HM GAME",
            (lang==="en")
              ? `ğŸ‰ Level cleared!<br/>
                 Next: <b>Level ${state.level+1}</b><br/>
                 Score: <b>${state.score}</b><br/>
                 Lives: <b>${state.b}</b> â€¢ Time: <b>${elapsed}</b>`
              : `ğŸ‰ ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©!<br/>
                 Ø§Ù„ØªØ§Ù„ÙŠ: <b>Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${state.level+1}</b><br/>
                 Ø§Ù„Ù†ØªÙŠØ¬Ø©: <b>${state.score}</b><br/>
                 Ø§Ù„Ø­ÙŠØ§Ø©: <b>${state.b}</b> â€¢ Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b>`,
            [
              { label: (lang==="en") ? "â¡ï¸ Next" : "â¡ï¸ Ø§Ù„ØªØ§Ù„ÙŠ", primary:true, onClick:()=>{
                  loadLevel(levelIndex+1, false);
                  hideOverlay();
                }
              },
              { label: `ğŸ” ${T[lang].restart}`, onClick:()=>{ loadLevel(levelIndex,false); hideOverlay(); } },
              { label: T[lang].backMenu, danger:true, onClick:()=>goMenu() },
            ]
          );
        } else {
          // YOU WIN
          setBest("bounce", state.score);
          const msg = (lang==="en")
            ? `ğŸ† <b>YOU WIN!</b><br/>
               You finished all levels ğŸ˜„<br/><br/>
               Final Score: <b>${state.score}</b><br/>
               Total Rings: <b>${state.a}</b><br/>
               Deaths: <b>${state.c}</b><br/>
               Time: <b>${elapsed}</b><br/><br/>
               ${T[lang].best}: <b>${state.best}</b>`
            : `ğŸ† <b>Ù„Ù‚Ø¯ Ø±Ø¨Ø­Øª!</b><br/>
               Ø£Ù†Ù‡ÙŠØª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ğŸ˜„<br/><br/>
               Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: <b>${state.score}</b><br/>
               Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø­Ù„Ù‚Ø§Øª: <b>${state.a}</b><br/>
               Ù…Ø±Ø§Øª Ø§Ù„Ø®Ø³Ø§Ø±Ø©: <b>${state.c}</b><br/>
               Ø§Ù„ÙˆÙ‚Øª: <b>${elapsed}</b><br/><br/>
               ${T[lang].best}: <b>${state.best}</b>`;

          showOverlay(
            `ğŸ† ${T[lang].youWin}`,
            msg,
            [
              { label:`ğŸ” ${T[lang].restart}`, primary:true, onClick:()=>{ init(); hideOverlay(); state.startedAt=now(); } },
              { label:T[lang].backMenu, danger:true, onClick:()=>goMenu() },
            ]
          );
        }
      }

      function draw(){
        // sky
        ctx.fillStyle = css("--sky");
        ctx.fillRect(0,0,cv.width,cv.height);

        // clouds (simple)
        ctx.fillStyle = "rgba(255,255,255,.35)";
        for (let i=0;i<6;i++){
          const x = ((i*280 + camX*0.15) % (cv.width+320)) - 160;
          const y = 70 + i*42;
          roundRect(x,y,150,36,18,true);
        }

        // tiles viewport
        const startTx = Math.floor(camX/TILE);
        const endTx = Math.ceil((camX+cv.width)/TILE);
        const startTy = Math.floor(camY/TILE);
        const endTy = Math.ceil((camY+cv.height)/TILE);

        for (let ty=startTy; ty<endTy; ty++){
          for (let tx=startTx; tx<endTx; tx++){
            const t = tileAt(tx,ty);
            const x = tx*TILE - camX;
            const y = ty*TILE - camY;

            if (t==="#") drawBrick(x,y);
            else if (t==="o") drawRing(x,y);
            else if (t==="^") drawSpike(x,y);
            else if (t==="G") drawGate(x,y);
          }
        }

        // ball
        drawBall(ball.x - camX, ball.y - camY, ball.r);

        // small text inside canvas (rings in current level)
        const ringNow = `${ringsCollectedInLevel()}/${ringsTotal}`;
        ctx.fillStyle = "rgba(0,0,0,.25)";
        ctx.font = `${Math.floor(Math.min(cv.width,cv.height)*0.032)}px system-ui`;
        ctx.textAlign = "left";
        ctx.fillText(`Rings: ${ringNow}`, 14, 34);
      }

      function drawBall(x,y,r){
        ctx.fillStyle = "rgba(0,0,0,.18)";
        ctx.beginPath();
        ctx.ellipse(x, y + r*0.85, r*1.05, r*0.35, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = css("--ball");
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,.30)";
        ctx.beginPath();
        ctx.arc(x - r*0.35, y - r*0.35, r*0.35, 0, Math.PI*2);
        ctx.fill();
      }

      function drawBrick(x,y){
        ctx.fillStyle = css("--brick");
        ctx.fillRect(x,y,TILE,TILE);
        ctx.fillStyle = "rgba(255,255,255,.10)";
        ctx.fillRect(x+2,y+2,TILE-4,5);
        ctx.fillStyle = "rgba(0,0,0,.12)";
        ctx.fillRect(x+2,y+TILE-6,TILE-4,4);
        ctx.strokeStyle = css("--brick2");
        ctx.lineWidth = 2;
        ctx.strokeRect(x+1,y+1,TILE-2,TILE-2);
      }

      function drawRing(x,y){
        ctx.strokeStyle = css("--ring");
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(x+TILE/2,y+TILE/2,TILE*0.28,0,Math.PI*2);
        ctx.stroke();

        ctx.strokeStyle = "rgba(255,255,255,.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x+TILE/2-1,y+TILE/2-2,TILE*0.22,0,Math.PI*2);
        ctx.stroke();
      }

      function drawSpike(x,y){
        ctx.fillStyle = css("--spike");
        ctx.beginPath();
        ctx.moveTo(x, y+TILE);
        ctx.lineTo(x+TILE*0.25, y+TILE*0.35);
        ctx.lineTo(x+TILE*0.5, y+TILE);
        ctx.lineTo(x+TILE*0.75, y+TILE*0.35);
        ctx.lineTo(x+TILE, y+TILE);
        ctx.closePath();
        ctx.fill();
      }

      function drawGate(x,y){
        ctx.fillStyle = "rgba(0,0,0,.18)";
        roundRect(x+2,y+2,TILE-4,TILE-4,7,true);
        ctx.strokeStyle = css("--gate");
        ctx.lineWidth = 2;
        roundRectStroke(x+4,y+4,TILE-8,TILE-8,6);

        ctx.fillStyle = "rgba(255,255,255,.88)";
        ctx.font = `${Math.floor(TILE*0.62)}px system-ui`;
        ctx.textAlign = "center";
        ctx.fillText("G", x+TILE/2, y+TILE*0.73);
      }

      function roundRect(x,y,w,h,r,fill){
        const rr = Math.min(r,w/2,h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
        if (fill) ctx.fill();
      }
      function roundRectStroke(x,y,w,h,r){
        const rr = Math.min(r,w/2,h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
        ctx.stroke();
      }

      Bounce.init = init;
      Bounce.update = update;
      Bounce.draw = draw;
    })();
})();
  </script>

</body>
</html>